[MISSING_PAGE_FAIL:1]

구체적 실행에서는 특정 입력에서 프로그램을 실행하고 단일 제어 유로를 탐색한다. 따라서 대부분의 경우 구체적인 실행은 관심 속성에 대한 분석을 과소 근사화할 수 있다. 대조적으로, 기호 실행은 프로그램이 다른 입력 하에서 취할 수 있는 여러 경로를 동시에 탐색할 수 있다. 이렇게 하면 확인된 부동산에 대한 강력한 보증을 제공할 수 있는 건전한 분석에 길을 열 수 있습니다. 핵심 아이디어는 프로그램이 구체적인 입력 값이 아닌 _상징적_ 값을 취할 수 있도록 하는 것이다. 실행은 탐색된 각 제어 흐름 경로에 대해 유지 관리되는 _상징 실행 엔진_에 의해 수행됩니다. (i) 해당 경로를 따라 취해진 분기에 의해 충족되는 조건을 설명하는 1차 부울 _공식_ 및 (ii) 변수를 기호 표현식 또는 값에 매핑하는 _상징 메모리 저장소_입니다. 분기 실행은 수식을 업데이트하는 반면 할당은 기호 저장소를 업데이트합니다. 일반적으로 _만족할 수 있는 모듈로 이론_(SMT) 해법(Ball et al., 2018)에 기초한 _모델 체커_는 결국 각각의 탐색된 경로를 따라 속성의 위반이 있는지 및 경로 자체가 실현 가능한 경우, 즉 프로그램의 상징적 인수에 대한 구체적인 값의 일부 할당에 의해 그 공식이 만족될 수 있는지를 검증하는 데 사용된다.

상징적 실행 기법은 2013년 DARPA가 취약점 탐지, 공격, 패치를 위한 자동 시스템을 거의 실시간으로 만들려고 하는 2년 간의 경쟁인 사이버 그랜드 챌린지를 발표한 이후 이질적인 청중의 관심을 끌었다(샌델, 2014). 더욱 놀랍게도, 심볼릭 실행 툴은 2008년부터 많은 마이크로소프트 애플리케이션의 테스트 프로세스에서 24시간 내내 실행되어, 예를 들어 윈도우 7의 개발 동안 파일 퍼징에 의해 발견된 모든 버그의 거의 30%를 드러냈으며, 이는 다른 프로그램 분석 및 블랙박스 테스트 기술이 누락되었다(Sandel, 2014).

이 글에서는 상징적 실행의 주요 측면을 조사하고 소프트웨어 테스트 및 컴퓨터 보안 응용 프로그램에서 사용되는 가장 두드러진 기술에 대해 논의한다. 우리의 논의는 주로 심볼 엔진이 프로그램의 주요 진입점에서 탐색을 시작하는 많은 경로를 동시에 분석하는 _전방향_ 심볼 실행에 초점을 맞추고 있다.

우리는 기사의 나머지 부분에서 다루어진 많은 근본적인 문제들을 강조하는 간단한 예로 시작한다.

### Warm-Up 예제

그림 1의 C 코드를 고려하고 함수 포박스의 8행에서 어떤 입력이 어써트를 실패시키는지 결정하는 것이 우리의 목표라고 가정한다. 각각의 4바이트 입력 파라미터는 \(2^{32}\)개의 서로 다른 정수 값을 가질 수 있기 때문에, 랜덤하게 생성된 입력들에 대한 구체적인 함수 포박스를 실행하는 접근법은 어써트-실패 입력들을 정확하게 포착하지 못할 것이다. 구체적인 값 대신 입력에 대한 기호를 사용하여 코드를 평가하면 기호 실행이 이러한 제한을 극복하고 단일 입력 값이 아닌 _입력 클래스_ 를 추론할 수 있습니다.

좀 더 자세히 설명하면, 함수의 실제 파라미터나 스트림으로부터 데이터를 읽어오는 시스템 호출의 결과와 같이 코드의 정적 분석으로 결정할 수 없는 모든 값은 심볼 \(\alpha_{i}\)으로 표현된다. 언제든지, 심볼릭 실행 엔진은 상태(\(stmt,\ \sigma,\ \pi\))를 유지하며, 여기서:

그림 1. 준비 예제: a와 b의 값이 어설션을 실패하게 만드는 것은 무엇입니까?

* \(stmt\)는 평가할 다음 문입니다. 당분간 우리는 \(stmt\)이 할당, 조건부 분기 또는 점프가 될 수 있다고 가정한다(함수 호출 및 루프와 같은 더 복잡한 구성은 섹션 5에서 논의될 것이다).
* \(\sigma\)는 프로그램 변수를 구체 값 또는 기호 값 \(\alpha_{i}\)에 대한 식과 연결하는 _기호 저장소_입니다.
* \(\pi\)는 _경로 제약 조건_ 을 나타냅니다. 즉, \(stmt\)에 도달하기 위해 실행에서 가져온 분기로 인해 기호 \(\alpha_{i}\)에 대한 일련의 가정을 표현하는 공식입니다. 분석 초기에는 \(\pi=true\).

\(stmt\)에 따라 심볼릭 엔진은 다음과 같이 상태를 변경합니다.

* 할당의 평가 \(x=e\)는 \(x\)을 새 기호 식 \(e_{s}\)과 연결 하 여 기호 저장소 \(\sigma\)를 업데이트 합니다. 본 논문에서는 현재 실행 상태에서의 \(e\)를 평가하여 \(x\mapsto e_{s}\)과의 연관성을 나타내며, 여기서 \(e_{s}\)은 심볼과 구체적인 값에 대한 단진수 또는 이진 연산자를 포함하는 표현일 수 있다.
* 조건부 분기의 평가는 \(e\) 다음에 \(s_{true}\) else\(s_{false}\)이 경로 제약 조건 \(\pi\)에 영향을 줍니다. 기호적 실행은 경로 제약 조건 \(\pi_{true}\)과 \(\pi_{false}\)을 갖는 두 개의 실행 상태를 생성함으로써 분기되며, 이는 \(\pi_{true}=\pi\wedge e_{s}\)과 \(\pi_{false}=\pi\wedge\neg e_{s}\)의 두 가지 분기에 해당하며, 여기서 \(e_{s}\)는 \(e\)을 평가하여 얻은 기호 표현이다. 상징적 집행은 두 주에서 독립적으로 진행된다.
* 점프의 평가는 기호 실행을 문 \(s\)으로 진행 하 여 실행 상태를 업데이트 합니다.

트리로 효과적으로 나타낼 수 있는 함수 포바의 기호 실행은 그림 2와 같다. 초기(실행 상태 \(A\)) 경로 제약 조건은 참이고 입력 인수 a와 b는 기호 값과 연관된다. 라인 2에서 로컬 변수 x 및 y를 초기화한 후, x 및 y를 각각 구체적인 값 1 및 0과 연관시켜 심볼릭 저장소를 업데이트한다(실행 상태 \(B\)) 라인 3은 조건부 분기를 포함하고 실행은 분기된다: 분기에 따라

그림 2: 그림 1에 주어진 함수 포바의 상징적 실행 트리. 대문자로 표시된 각 실행 상태는 실행할 문장, 상징적 저장소 \(\sigma\), 경로 제약 조건 \(\pi\)을 보여준다. 잎은 주장 진술의 조건에 대해 평가된다.

다음에 다른 문장이 평가되고 심볼 \(\alpha_{a}\)(실행 상태 \(C\) 및 \(D\)에 대해 각각 다른 가정이 이루어진다. \(\alpha_{a}\neq 0\)인 분기에서 변수 y는 x + 3으로 할당되어 상태 \(E\)에서 \(y\mapsto 4\)을 얻는다. 왜냐하면 상태 \(C\)에서 \(x\mapsto 1\)이기 때문이다. 일반적으로 산술 표현 평가는 단순히 기호 값을 조작한다. 모든 브랜치에서 8행의 어써트가 도달할 때까지 모든 실행 상태를 확장한 후 파라미터 a와 b에 대한 어떤 입력 값이 어써트를 실패할 수 있는지 확인할 수 있다. 실행 상태 \(\{D,G,H\}\)를 분석하면 \(H\)만이 x-y = \(\emptyset\)을 참으로 만들 수 있다는 결론을 내릴 수 있다. 이 시점에서 \(H\)에 대한 경로 제약 조건은 바보에게 안전하지 않은 입력 집합을 암시적으로 정의한다. 특히, 다음과 같은 임의의 입력 값들:

\[2(\alpha_{a}+\alpha_{b})-4=0\wedge\alpha_{a}\neq 0\wedge\alpha_{b}=0\]

단언은 실패할 것이다. 불안전한 입력 파라미터의 인스턴스는 경로 제약을 해결하기 위해 _SMT 솔버_(Kolmogorov, 1999)를 호출함으로써 결국 결정될 수 있으며, 이 예에서는 \(a=2\) 및 \(b=0\)을 산출할 것이다.

### Symbolic Execution의 문제

섹션 1.1에서 논의 된 예제에서 기호 실행은 어설션을 실패 하는 _모든_ 가능한 안전하지 않은 입력을 식별할 수 있습니다. 이는 가능한 실행 상태에 대한 철저한 탐구를 통해 달성된다. 이론적 관점에서 철저한 기호 실행은 모든 결정 가능한 분석을 위한 _사운드_ 및 _완전한_ 방법론을 제공합니다. 건전성은 거짓 부정, 즉 모든 가능한 안전하지 않은 입력이 발견되도록 보장되는 반면 완전성은 거짓 긍정, 즉 안전하지 않은 것으로 간주되는 입력 값이 실제로 안전하지 않음을 방지한다. 나중에 논의하겠지만, 철저한 상징적 실행은 소규모 애플리케이션을 넘어 확장될 것 같지 않다. 따라서 실제로 우리는 종종 성과를 위해 건전성을 거래함으로써 덜 야심찬 목표에 안주한다.

실제 코드를 처리할 때 기호 실행이 직면해야 하는 문제는 우리의 준비 예제에 예시된 것보다 훨씬 더 복잡할 수 있다. 여러 가지 관찰과 질문이 자연스럽게 발생한다.

* _메모리:_ 기호 엔진은 포인터, 배열 또는 기타 복잡한 개체를 어떻게 처리합니까? 포인터들 및 데이터 구조들을 조작하는 코드는 심볼릭 저장된 데이터뿐만 아니라 심볼릭 표현들에 의해 기술되는 어드레스들을 발생시킬 수 있다.
* _환경:_ 엔진은 소프트웨어 스택 간의 상호 작용을 어떻게 처리합니까? 라이브러리 및 시스템 코드로의 호출은 나중에 실행에 영향을 미칠 수 있고 설명되어야 하는 파일 생성 또는 사용자 코드로의 호출과 같은 부작용을 일으킬 수 있다. 그러나 가능한 상호 작용 결과를 평가하는 것은 불가능할 수 있다.
* _상태 공간 폭발_: 기호 실행은 경로 폭발을 어떻게 처리합니까? 루프와 같은 언어 구성은 실행 상태의 수를 기하급수적으로 증가시킬 수 있습니다. 따라서 상징 실행 엔진이 합리적인 시간 내에 가능한 모든 상태를 철저하게 탐색할 수 있을 것 같지 않다.
* _제약 조건 해결_: 제약 조건 해결자가 실제로 수행할 수 있는 작업은 무엇입니까? SMT 해결자는 수백 개의 변수에 걸쳐 제약 조건의 복잡한 조합으로 스케일링할 수 있다. 그러나 비선형 연산과 같은 구조는 효율성에 큰 장애가 된다.

상징적 실행이 사용되는 특정 맥락에 따라 위에서 강조된 질문을 해결하기 위해 다양한 선택과 가정이 이루어진다. 이러한 선택이 전형적으로 건전성 또는 완전성에 영향을 주지만, 여러 시나리오에서 가능한 실행 상태의 공간에 대한 부분적인 탐색은 제한된 시간 예산 내에서 목표(예를 들어, 애플리케이션에 대한 크래싱 입력을 식별하는 것)를 달성하기에 충분할 수 있다.

### Related Work

상징적 실행은 방대한 문학의 초점이었다. 구글 스칼라는 2017년 8월 현재 제목에 '상징적 집행'이라는 정확한 문구가 포함된 기사 742건을 보도하고 있다. 이 조사에 앞서 다른 저자들은 (Kang et al., 2018) 및 (Kang et al., 2019)와 같은 해당 분야의 기술적 개요에 기여했다. (Kang et al., 2019)는 자동화된 테스트 생성의 보다 구체적인 설정에 초점을 맞추고 있다: 이는 문헌의 포괄적인 관점을 제공하며, 다양한 기술을 심층적으로 다루고 다수의 실행 사례로 기술적 논의를 보완한다.

### 문서 구성

이 글의 나머지 부분은 다음과 같이 구성되어 있다. 2절에서는 상징적 실행 엔진의 전반적인 원칙과 평가 전략에 대해 논의한다. 섹션 3에서 섹션 6까지의 섹션은 섹션 1.2에 나열된 주요 문제를 다루고 섹션 7은 다른 영역의 최근 발전이 상징 실행 기술을 향상시키기 위해 어떻게 적용될 수 있는지 논의한다. 결론 발언은 섹션 8에서 다루어진다.

## 2 Symbolic Execution Engines

이 섹션에서는 상징 실행기의 설계에 대한 몇 가지 중요한 원칙과 구현에 발생하는 중요한 절충안을 설명한다. 구체적이고 상징적인 실행의 개념에서 벗어나, 우리는 또한 _concolic_ 실행의 개념을 도입한다.

### 상징 및 콘크리트 실행 혼합

준비 예(섹션 1.1)에 도시된 바와 같이, 프로그램의 상징적 실행은 이론적으로 프로그램이 특정 입력에 대한 구체적인 실행 동안 취할 수 있는 모든 가능한 제어 흐름 경로를 생성할 수 있다. 가능한 모든 실행을 모델링하면 매우 흥미로운 분석이 가능하지만 일반적으로 실제로, 특히 실제 소프트웨어에서는 불가능하다.

고전적 상징 실행의 주요 한계는 다룰 수 없는 경로 제약을 초래할 실현 가능한 실행을 탐색할 수 없다는 것이다(Kang et al., 2019). 건전성 손실은 실행자가 추적할 수 없는 외부 코드뿐만 아니라 비선형 산술 또는 초월 함수와 관련된 복잡한 제약에서 비롯된다. 제약조건 해결에 소요되는 시간이 엔진의 주요 성능 장벽이기 때문에, 해결 가능성은 절대적인 의미에서 의도될 수 있지만 효율성도 마찬가지이다. 또한, 실용적인 프로그램들은 전형적으로 독립적이지 않다: 전체 소프트웨어 스택을 정적으로 분석할 수 있는 기호 엔진을 구현하는 것은 실행 동안 임의의 가능한 부작용을 정확하게 평가하는 데 어려움을 고려할 때 다소 어려울 수 있다. 이러한 문제에 대처하고 상징적 실행을 실제로 실현 가능하게 하기 위한 근본적인 아이디어는 구체적이고 상징적인 실행을 혼합하는 것이다. 이것은 "콘콜릭 실행"이라고 하며, 여기서 콘콜릭이라는 용어는 "구체적"과 "상징적"이라는 단어의 문맥이다. 이 일반 원리는 이 섹션의 나머지 부분에서 논의된 다양한 각도를 따라 탐구되었다.

동적 Symbolic ExecutionOne 대중적인 콘콜릭 실행 접근법, 예컨대 _동적 심볼릭 실행_(DSE) 또는 _동적 테스트 생성_(Kang et al., 2019)은 구체적인 실행 드라이브 심볼릭 실행을 갖는 것이다. 이 기술은 위의 문제를 완화하는 데 매우 효과적일 수 있다. 상기 상징적인 스토어 및 상기 경로 제약에 더하여, 상기 실행 엔진은 콘크리트 스토어를 유지하는

도 3. 구체적이고 추상적인 실행 기계 모델.

\(\sigma_{c}\). 먼저 임의의 입력을 선택한 후, 두 개의 저장소와 경로 제약 조건을 동시에 업데이트하여 구체적이고 상징적으로 프로그램을 실행한다. 구체적 실행이 분기(branch)를 취할 때마다, 상징적 실행은 동일한 분기(branch)를 향하게 되고 분기 조건으로부터 추출된 제약조건들은 현재의 경로 제약조건 세트에 추가된다. 요컨대 상징적 실행은 특정한 구체적 실행에 의해 주도된다. 결과적으로, 심볼 엔진은 분기 조건이 만족스럽지 않은지 여부를 결정하기 위해 제약 해법을 호출할 필요가 없으며, 이는 콘크리트 실행에 의해 직접 테스트된다. 상이한 경로들을 탐색하기 위해, 하나 이상의 브랜치들에 의해 주어진 경로 조건들은 부정될 수 있고, 새로운 제약들에 대한 만족스러운 할당을 찾기 위해, 즉 새로운 입력을 생성하기 위해 SMT 해결기가 호출된다. 이 전략은 원하는 커버리지를 달성하기 위해 필요한 만큼 반복될 수 있다.

**예제**.: 그림 1의 C 함수를 고려 하 고 입력 매개 변수로 \(a=1\) 및 \(b=1\)을 선택 한다고 가정 합니다. 이러한 조건에서 콘크리트 실행은 그림 2의 상징 트리에서 경로 \(A\leadsto B\leadsto C\leadsto E\leadsto G\)를 취한다. 그림 2에 표시된 상징 저장소 외에 횡단된 상태로 유지되는 콘크리트 저장소는 다음과 같다.

* \(\sigma_{c}=\{a\mapsto 1,\ b\mapsto 1\}\) in state \(A\);
* \(\sigma_{c}=\{a\mapsto 1,\ b\mapsto 1,\ x\mapsto 1,\ y\mapsto 0\}\) in states \(B\) and \(C\);
* \(\sigma_{c}=\{a\mapsto 1,\ b\mapsto 1,\ x\mapsto 1,\ y\mapsto 4\}\) in states \(E\) and \(G\)

8행의 어써트 조건이 성공하는지 확인한 후, 마지막 경로 제약 조건인 \(\alpha_{b}\neq 0\)을 무효화함으로써 새로운 제어 흐름 경로를 생성할 수 있다. 이때의 해결자는 제약조건 \(\alpha_{a}\neq 0\ \land\ \alpha_{b}=0\)(예를 들어 \(a=1\) 및 \(b=0\))을 만족하는 새로운 입력을 생성하며, 실행은 경로 \(A\leadsto B\leadsto C\leadsto E\leadsto F\)를 따라 유사한 방식으로 계속된다.

DSE는 특정 경로를 향해 상징적 실행을 유도하기 위해 구체적인 입력을 사용하지만, 새로운 경로를 탐색해야 할 때마다 부정할 분기를 선택해야 한다. 또한 각 구체적인 실행이 방문해야 할 새로운 지점을 추가할 수 있습니다. 수행된 모든 구체적인 실행에 걸쳐 포착되지 않은 분기 집합은 매우 클 수 있기 때문에 효과적인 검색 휴리스틱(섹션 2.2)을 채택하는 것이 중요한 역할을 할 수 있다. 예를 들어, DART[51]는 깊이 우선 전략을 사용하여 무효화할 다음 브랜치를 선택한다. 부정할 다음 가지를 선택하기 위한 추가 전략이 문헌에 제시되었다. 예를 들어 SAGE [52]의 _세대 검색_ 은 체계적이면서도 부분적으로 상태 공간을 탐색 하 여 생성 된 새 테스트의 수를 최대화 하는 동시에 검색의 중복을 방지 합니다. 이것은 특정 순서에 따르는 제약들을 부정하고 검색 알고리즘의 역추적을 제한함으로써 달성된다. 국가 공간은 부분적으로만 탐구되기 때문에 초기 투입은 전체 접근의 효과성에 중요한 역할을 한다. 첫 번째 입력의 중요성은 기존 _black-box fuzzing_ 에서 발생 하는 것과 유사 합니다. 따라서 SAGE와 같은 기호 엔진은 종종 _white-box fuzzers_ 라고 합니다.

콘크리트 실행 중에 유지 관리되는 기호 정보는 엔진에 의해 새로운 입력을 얻고 새로운 경로를 탐색할 수 있습니다. 다음 예는 DSE가 콘콜릭 엔진에 의해 심볼적으로 추적되지 않는 외부 코드에 대한 호출들을 어떻게 처리할 수 있는지를 보여준다. 제약 조건 해결을 돕기 위한 구체적인 값의 사용은 섹션 6에서 논의될 것이다.

**예제**: 그림 3(a)에서 함수 foo를 고려 하 고 막대가 콘콜릭 엔진에 의해 기호적으로 추적 되지 않는다고 가정 합니다 (예: 타사 구성 요소에 의해 제공 되거나 다른 언어로 작성 되거나 블랙 박스 접근 방식에 따라 분석 될 수 있습니다). \(x=1\) 및 \(y=2\)이 초기 입력 매개 변수로 무작위로 선택된다고 가정하면 콘콜릭 엔진은 막대( \(a=0\)를 반환하고 오류 문을 트리거하는 분기를 건너뜁니다. 동시에 심볼릭 실행은 함수 foo 내부의 경로 제약 조건 \(\alpha_{y}\geq 0\)을 추적한다. 기능 막대의 분기 조건이 엔진에 알려져 있지 않습니다. 대체 경로를 탐색하기 위해 엔진은 foo에서 분기의 경로 제약을 무효화하여 실제로 대체 경로로 구체 실행을 유도하는 \(x=1\) 및 \(y=-4\)과 같은 입력을 생성한다. 이 방법을 사용하면 막대가 기호적으로 추적되지 않더라도 엔진은 foo의 두 경로를 모두 탐색할 수 있습니다.

이전 코드의 변형은 그림 4b에 나와 있으며, 함수 qux는 foo와 다르게 단일 입력 매개변수를 취하지만 분기 조건에서 막대의 결과를 확인한다. 엔진은 qux 내부에서 테스트된 분기 조건에서 경로 제약을 추적할 수 있지만, 대체 경로를 향해 실행을 구동할 수 있는 입력이 생성된다는 보장은 없다. \(a\)와 \(x\) 사이의 관계는 막대가 상징적으로 추적되지 않기 때문에 콘콜릭 엔진에 알려져 있지 않다. 이 경우 엔진은 다른 무작위 입력을 사용하여 코드를 다시 실행할 수 있지만 결국 쿼스에서 하나의 흥미로운 경로를 탐색하지 못할 수 있다.

관련 이슈가 도 4c에 의해 제시된다. 예측 된 경로에 대해 생성 된 입력이 다른 경로로 실행 될 때 _경로 발산_ 을 관찰 합니다. 일반적으로, 이것은 심볼 전파가 추적되지 않아 부정확한 경로 제약들을 초래하거나, 엔진에서 특정(예를 들어, 비트 와이즈, 부동 소수점) 동작들을 모델링하는데 있어서 부정확하기 때문일 수 있다. 예제에서 함수 baz는 외부 함수 abs를 호출하며, 이는 \(x\)에 대한 부작용을 절대값으로 할당하여 수행한다. 초기 콘크리트 값으로 \(x=1\)을 선택하면, 콘크리트 실행은 오류문을 유발하지 않지만, 콘콜릭 엔진은 baz의 분기로 인한 경로 제약 조건 \(\alpha_{x}\geq 0\)을 추적하여 이를 부정함으로써 새로운 입력을 생성하려고 한다. 그러나 새로운 입력(예: \(x=-1\)은 복근의 (추적되지 않은) 부작용으로 인해 오류 문을 트리거하지 않는다. 흥미롭게도 엔진은 어떤 입력도 실제로 오류를 유발할 수 없다는 것을 감지할 방법이 없다.

예에 의해 보여지는 바와 같이, 거짓 부정들(즉, 누락된 경로들) 및 경로 분기들은 동적 심볼 실행의 주목할 만한 단점들이다. DSE는 성능 및 구현 노력에 대한 건전성을 거래하며, 일부 프로그램 실행(따라서 가능한 잘못된 행동)을 놓칠 수 있기 때문에 거짓 음수(false negative)가 가능하며, 이는 프로그램 분석의 _완전_이지만 _근사_ 형태로 이어질 수 있다. 경로 분기는 문헌에서 자주 관찰되었는데, 예를 들어 [52] 보고서 비율이 60% 이상이다. [27] 이 현상에 기여하는 주요 패턴을 분석하여 경로 분기에 대한 경험적 연구를 제시한다. 외부 호출, 예외, 유형 캐스트 및 기호 포인터는 경로 분기 수를 줄이기 위해 엔진에서 주의 깊게 처리해야 하는 콘콜릭 실행의 중요한 측면으로 지적된다.

**선택적 기호 실행**: \({}^{2}\)E [29]는 다른 구성 요소에 대해 신경 쓰지 않고 소프트웨어 스택의 일부 구성 요소만 완전히 탐색하려는 관찰에 따라 기호 실행과 구체 실행을 혼합하는 다른 접근 방식을 사용합니다. _ 선택적 기호 실행_은 전체 탐구를 의미 있게 유지하면서 콘크리트와 기호 실행을 신중하게 인터리빙합니다.

함수 A가 함수 B를 호출하고 호출 사이트에서 실행 모드가 변경된다고 가정하자. 두 가지 시나리오가 발생한다: (1) _구체적에서 상징적, 역으로_: B의 주장은 상징적으로 만들어지고 B는 상징적으로 완전히 탐구된다. B도 구체적으로 실행되고, 그 구체적인 결과는 A로 되돌아간다. 그 후, A는 구체적으로 재개된다. (2) _기호로부터 구체 및 역으로_: B의 인수가 구체화되고, B가 구체화되고, 실행이 A에서 상징적으로 재개된다. 이것은 분석의 건전성과 완전성 모두에 영향을 미칠 수 있다: (i) _완전성_: 상징적 실행이 수행된 구체화로 인해 실현 가능하지 않을 임의의 경로를 건너뛰도록 하는 것

도 4: 콘콜릭 실행: (a) 막대가 엔진에 의해 상징적으로 추적될 수 없는 경우에도 함수 foo의 테스트, (b) 거짓 음성의 예, 및 (c) 경로 발산의 예, 여기서 abs는 &x에서 정수의 부호를 떨어뜨린다.

(잘못된 긍정으로 이어질 수 있음), S\({}^{2}\)E는 인수가 구체화되는 방법, B에 의해 어떤 부작용이 발생하고 어떤 반환 값을 생성하는지를 추적하는 경로 제약을 수집한다. (ii) _건전성_: 구체화는 A가 재개된 후 누락된 분기를 야기할 수 있다(아마도 위음성으로 이어질 수 있음). 이를 개선하기 위해 수집된 제약 조건은 _soft_로 표시되며, A로 돌아온 후 분기가 소프트 제약 조건에 의해 작동하지 않을 때마다 실행 백트랙 및 B에 대한 다른 인수 선택을 시도한다. 또한 S\({}^{2}\)E는 B를 실행하는 과정에서 분기조건을 수집하고, B에서 다른 콘크리트 실행경로가 가능하도록 콘크리트 값을 선택한다.

### Path Selection

프로그램의 모든 경로를 열거하는 것은 엄청나게 비용이 많이 들 수 있기 때문에, 테스트 및 디버깅과 관련된 많은 소프트웨어 공학 활동에서 가장 유망한 경로를 먼저 살펴봄으로써 검색이 우선시된다. 다음 탐색할 경로를 선택하기 위한 여러 전략 중 이제 가장 효과적인 몇 가지 전략에 대해 간략하게 설명한다. 우리는 경로 선택 휴리스틱이 종종 심볼릭 엔진이 특정 목표(예를 들어, 오버플로우 검출)를 달성하는 것을 돕기 위해 맞춤화된다는 점에 주목한다. 보편적으로 최적의 전략을 찾는 것은 여전히 열린 문제로 남아 있다.

가장 깊이 탐색되지 않은 분기로 역추적하기 전에 최대한 경로를 확장하는 DFS(_Depth-first search_)와 모든 경로를 병렬로 확장하는 BFS(Bbreadth-first search_)가 가장 일반적인 전략이다. DFS는 메모리 사용량이 프리미엄일 때 종종 채택되지만, 루프 및 재귀 호출을 포함하는 경로에 의해 방해를 받는다. 따라서 더 높은 메모리 압력과 특정 경로의 탐색을 완료하는 데 필요한 긴 시간에도 불구하고 일부 도구는 BFS에 의존하여 엔진이 흥미로운 행동을 조기에 감지하는 다양한 경로를 빠르게 탐색할 수 있다. 또 다른 인기 있는 전략은 여러 변형에서 정제된 무작위 경로 선택이다. 예를 들어, KLEE[20]는 경로들의 길이 및 분기 아리티에 기초하여 경로들에 확률들을 할당한다: 그것은 루프들 및 다른 경로 폭발 인자들에 의해 야기되는 기아들을 방지하면서 더 적게 탐색된 경로들을 선호한다.

EXE[21], KLEE[20], Mayhem[25], S\({}^{2}\)E[29]와 같은 여러 연구에서 코드 커버리지를 최대화하기 위한 휴리스틱에 대해 논의하였다. 예를 들어 KLEE [20]에서 논의 된 _커버리지 최적화 검색_ 은 나중에 상태를 무작위로 선택 하는 데 사용 되는 각 상태 가중치에 대해 계산 합니다. 가중치는 가장 가까운 언커버링된 명령어가 얼마나 멀리 있는지, 새로운 코드가 최근에 스테이트에 의해 커버되었는지 여부 및 스테이트의 호출 스택을 고려하여 획득된다. 유사한 풍미가 [71]에서 제안된 휴리스틱(subpath-guided search_)인데, 이 휴리스틱은 탐색 횟수가 적은 제어 흐름 그래프의 하위 경로를 선택하여 프로그램의 _덜 이동된_ 부분을 탐색하려고 시도한다. 이는 탐색된 서브패스들의 주파수 분포를 유지함으로써 달성되며, 여기서 서브패스는 완전한 경로로부터 길이 \(n\)의 연속적인 서브시퀀스로 정의된다. 흥미롭게도, 값 \(n\)은 이 휴리스틱을 사용하여 기호 엔진에 의해 달성되는 코드 범위와 관련하여 중요한 역할을 하며 특정 값은 보편적으로 최적인 것으로 나타나지 않았다. _ 최단 거리 심볼릭 실행_[72]은 커버리지를 타겟팅하는 것이 아니라, 프로그램 내의 특정 포인트의 실행을 트리거하는 프로그램 입력들을 식별하는 것을 목표로 한다. 그러나 휴리스틱은 커버리지 기반 전략과 마찬가지로 목표 지점까지의 최단 거리를 평가하기 위한 메트릭을 기반으로 한다. 이것은 절차간 제어 흐름 그래프에서 최단 경로의 길이로 계산되며, 최단 거리를 갖는 경로는 엔진에 의해 우선된다.

다른 검색 휴리스틱은 일부 목표에 따라 _흥미롭음_ 상태로 이어질 가능성이 있는 경로의 우선 순위를 지정하려고 합니다. 예를 들어, AEG [8]은 이러한 두 가지 전략을 소개한다. _버기 경로 첫 번째_ 전략은 과거 주에 작지만 탐색할 수 없는 버그가 포함된 경로를 선택합니다. 직관은 경로에 약간의 작은 오류가 포함되어 있으면 제대로 테스트되지 않았을 가능성이 높다는 것이다. 따라서 미래 주에는 흥미롭고 희망적으로 착취할 수 있는 버그가 포함될 가능성이 충분히 있다. 마찬가지로 _루프 소진_ 전략은 루프를 방문하는 경로를 탐색합니다. 이 접근법은 루프에서 일반적인 프로그래밍 실수가 버퍼 오버플로우 또는 다른 메모리 관련 오류로 이어질 수 있다는 실제 관찰에서 영감을 얻었다. 공격 가능한 버그를 찾기 위해 Mayhem[25]은 대신 심볼 주소에 대한 메모리 액세스가 식별되거나 심볼 지시 포인터가 검출되는 경로에 우선 순위를 부여한다.

[118]은 정규 속성, 즉 FSM(Finite State Machine)에 의해 표현될 수 있는 속성(파일 사용 또는 메모리 안전과 같은)을 만족하는 프로그램 경로를 자동으로 찾기 위한 새로운 동적 심볼릭 실행 방법을 제안한다. 동적 기호 실행은 속성을 충족할 가능성이 가장 높은 실행 경로의 분기가 먼저 탐색되도록 FSM에 의해 안내됩니다. 이 방법은 탐색을 위해 선택할 경로의 우선 순위를 계산하기 위해 정적 분석과 동적 분석을 모두 이용하는데, 현재 실행 경로가 이미 도달한 FSM의 상태는 심볼릭 실행 동안 동적으로 계산되는 반면, 역방향 데이터 흐름 분석은 미래 상태를 정적으로 계산하는 데 사용된다. 이 두 집합의 교집합이 비어 있지 않다면 성질을 만족하는 경로가 있을 가능성이 있다.

_적합도 함수_는 검색 기반 테스트 생성의 맥락에서 주로 사용되어 왔다[76]. 적합도 함수는 탐색된 경로가 목표 테스트 범위를 달성하는 데 얼마나 가까운지를 측정합니다. 여러 작품, 예를 들어 [22, 112]는 상징적 실행의 맥락에서 이 아이디어를 적용했다. 예를 들어 [112]는 특정 분기를 취할 가능성이 있는 경로를 우선 지정하는 콘콜릭 실행에서 분기를 뒤집는 전략인 _fitnex_를 도입합니다. 자세히 설명하면, 형태 \(|a-c|==0\)의 관련 조건을 갖는 대상 분기가 주어졌을 때, 경로의 근접성은 해당 경로에서 변수 \(a\) 및 \(c\)의 구체적인 값을 활용하여 \(|a-c|\)으로 계산된다. 다른 종류의 분기 조건에 대해서도 유사한 적합도 값을 계산할 수 있다. 분기 적합도 값이 가장 낮은 경로는 기호 엔진에 의해 선택됩니다. 분기에 도달하지 않은 경로는 최악의 적합도 값을 얻습니다.

### Symbolic Backward Execution

상징적 역방향 실행(Symbolic Backward Execution; SBE)[26, 40]은 탐색이 프로그램의 목표 지점에서 진입 지점으로 진행하는 상징적 실행의 변형이다. 따라서 분석은 표준(순방향) 기호 실행보다 역방향으로 수행된다. 이 접근법의 주요 목적은 전형적으로 특정 코드 라인(예를 들어, 어써트 또는 스로우 문)의 실행을 트리거할 수 있는 테스트 입력 인스턴스를 식별하는 것이다. 이것은 프로그램을 통해 디버깅 또는 회귀 테스트를 수행할 때 개발자에게 매우 유용할 수 있다. 탐사가 목표로부터 시작됨에 따라, 경로 제약들은 횡단 동안 만나는 분기들을 따라 수집된다. 다중 경로는 SBE 엔진에 의해 한번에 탐색될 수 있고, 순방향 심볼 실행과 유사하게, 경로들은 실현가능성에 대해 주기적으로 체크된다. 경로 조건이 만족스럽지 못한 것으로 판명되면, 엔진은 경로를 폐기하고 백트랙을 수행한다.

[72]는 _call-chain backward symbolic execution_ (CCBSE)라고 불리는 SBE의 변형에 대해 논의한다. 이 기법은 대상 선이 위치한 함수에서 유효한 경로를 결정함으로써 시작된다. 경로가 발견되면, 엔진은 목표 지점을 포함하는 함수의 호출자 중 하나로 이동하여 호출자의 진입 지점으로부터 목표 지점까지의 유효한 경로를 재구성하려고 한다. 프로세스는 프로그램의 주 기능으로부터 유효한 경로가 재구성될 때까지 재귀적으로 반복된다. 전통적인 SBE와 관련하여 주요 차이점은 CCBSE가 목표 지점에서 콜체인을 거꾸로 따르지만 각 기능 내부에서 탐구는 전통적인 상징 실행에서와 같이 수행된다는 것이다.

CCBSE뿐만 아니라 SBE에서 역탐사를 위한 중요한 요구 사항은 전체 프로그램 제어 흐름을 제공하고 탐사에 관련된 함수에 대한 호출 사이트를 결정할 수 있도록 하는 절차 간 제어 흐름 그래프의 가용성이다. 불행히도 그러한 그래프를 구성하는 것은 실제로 상당히 어려울 수 있다. 더욱이, 함수는 많은 가능한 호출 사이트들을 가질 수 있고, SBE에 의해 수행되는 탐사를 여전히 매우 비싸게 만든다.

한편, 제약들이 역방향으로 수집될 때 일부 실용적인 이점들이 발생할 수 있다. 우리는 섹션 6에서 이러한 이점에 대해 더 논의할 것이다.

### Symbolic Executors의 설계 원리

상징적 실행 엔진이 따라야 하는 다수의 성능 관련 설계 원리들이 요약된다(Krishnan et al., 2017). 가장 눈에 띄는 건

1. _진행률_: 실행자는 지정된 리소스를 초과하지 않고 임의로 장기간 진행할 수 있어야 합니다. 메모리 소비는 잠재적으로 엄청난 수의 별개의 제어 흐름 경로로 인해 특히 중요할 수 있다.
2. _작업 반복_: 공통 접두사가 있을 수 있는 다른 경로를 분석하기 위해 처음부터 여러 번 프로그램을 다시 시작하는 것을 피하면서 실행 작업을 반복해서는 안 됩니다.
3. _분석 재사용_: 이전 실행의 분석 결과를 최대한 재사용해야 합니다. 특히, 이전에 해결된 경로 제약들에 대한 SMT 해결기에 대한 값비싼 호출들은 피해야 한다.

분석될 실행 상태 공간의 큰 크기로 인해, 상이한 심볼 엔진들은 예를 들어, 실행 시간 및 메모리 소비, 또는 분석의 성능 및 건전성/완전성 사이의 상이한 트레이드-오프들을 탐구해 왔다.

단일 실행에서 여러 경로를 동시에 실행하려고 시도하는 기호 실행기( _online_이라고도 함)는 각 입력 종속 분기에서 실행 상태를 복제합니다. 예들은 KLEE(Kleiner et al., 2017), AEG(Ball et al., 2018), S\({}^{2}\)E(Kleiner et al., 2019)에서 주어진다. 이 엔진은 이전 명령을 다시 실행하지 않으므로 작업 반복을 방지합니다. 그러나, 많은 활성 상태들은 메모리에 유지될 필요가 있고 메모리 소모가 클 수 있으며, 아마도 진행을 방해할 수 있다. 메모리 풋프린트를 감소시키기 위한 효과적인 기술로는 _copy-on-write_가 있으며, 이는 서로 다른 상태들 사이에서 가능한 한 많이 공유하려고 한다(Kleiner et al., 2017). 또 다른 이슈로서, 다수의 경로들을 병렬로 실행하는 것은 실행 상태들 사이의 격리, 예를 들어 시스템 호출들의 효과들을 에뮬레이트함으로써 OS의 상이한 상태들을 유지하는 것을 보장할 것을 요구한다.

콘콜릭 실행에서와 같이 한 번에 단일 경로에 대해 추론하는 것은 SAGE(Sage et al., 2018)와 같은 소위 _오프라인 실행기_에 의해 취해진 접근법이다. 각 경로를 다른 경로와 독립적으로 실행하면 온라인 실행기와 관련하여 메모리 소모가 적고 이전 실행의 즉시 분석 결과를 재사용할 수 있다. 다른 한편으로, 작업은 크게 반복될 수 있는데, 그 이유는 각각의 실행이 보통 처음부터 프로그램의 실행을 재시작하기 때문이다. 오프라인 실행기의 전형적인 구현에서, 실행은 구체적이며 입력 시드를 필요로 한다 : 프로그램은 먼저 구체적으로 실행되고, 명령어들의 트레이스가 기록되고, 기록된 트레이스는 이어서 상징적으로 실행된다. _ Mayhem(Krishnan et al., 2017)과 같은 하이브리드 실행기_는 속도와 메모리 요구사항 사이의 균형을 시도한다: 이들은 메모리 사용량 또는 동시 활성 상태의 수가 임계값에 도달할 때 새로운 실행기를 포킹하는 것이 아니라 온라인 모드에서 시작하고 체크포인트를 생성한다. 체크포인트는 기호 실행 상태 및 재생 정보를 유지합니다. 복원을 위해 검문소를 선택하면 복구된 콘크리트 상태에서 온라인 탐사가 재개된다.

## 3. Memory Model

섹션 1.1의 예열 예는 데이터가 방향 없이 스칼라 변수에만 저장되는 단순화된 메모리 모델을 제시했다. 상징적 실행의 중요한 측면은 포인터와 어레이가 있는 프로그램을 지원하기 위해 메모리를 모델링하는 방법이다. 이를 위해서는 변수뿐만 아니라 메모리 주소를 기호 표현이나 구체적인 값으로 매핑하여 메모리 저장 개념을 확장해야 한다. 일반적으로 메모리 주소를 명시적으로 모델링하는 저장소 \(\sigma\)는 메모리 주소(인덱스)를 구체적인 값 또는 기호 값에 대한 식과 연결하는 매핑으로 생각할 수 있습니다. 매핑에서 이름이 아닌 주소를 사용하여 변수를 지원할 수 있습니다. 다음에서 변수 \(x\)에 대한 \(x\mapsto e\)과 식 \(e\)을 쓸 때 \(\delta x\mapsto e\)을 의미하며, 여기서 \(\delta x\)는 변수 \(x\)의 구체적인 주소이다. 또한, \(v\)이 배열이고 \(c\)이 정수 상수이면 \(v[c]\mapsto e\)은 \(\delta v+c\mapsto e\)을 의미한다.

메모리 모델은 탐색에 의해 달성되는 커버리지와 제약 해결의 확장성에 상당한 영향을 미칠 수 있기 때문에 상징 엔진에 대한 중요한 설계 선택이다(Kang and Zemel, 2018). _기호 메모리 주소_ 문제 (Zemel, 2018)는 작업에서 참조 되는 주소가 기호 표현식일 때 발생 합니다. 이 섹션의 나머지 부분에서 우리는 많은 인기 있는 솔루션에 대해 논의한다.

### 완전 Symbolic Memory

가장 높은 수준의 일반성에서 엔진은 메모리 주소를 완전히 상징적인 것으로 취급할 수 있다. 이것은 다수의 작업(예를 들어, BitBlaze(Zemel, 2018), BAP(Barb 등, 2018), 및 (Kang and Zemel, 2018))에 의해 취해진 접근법이다. 킹이 주요 논문(제멜, 2018)에서 개척한 두 가지 근본적인 접근법은 다음과 같다.

* _상태 포킹_ 입니다. 연산이 심볼릭 어드레스로부터 판독하거나 또는 심볼릭 어드레스에 기록하는 경우, 상태는 연산으로부터 초래될 수 있는 모든 가능한 상태들을 고려함으로써 분기된다. 경로 제약들은 각각의 포크 상태에 대해 그에 따라 업데이트된다.

**예제.** 그림 5에 표시된 코드를 고려합니다. 4행의 쓰기 작업은 배열 인덱스 \(i\)의 알 수 없는 값에 따라 \(a[0]\) 또는 \(a[1]\에 영향을 줍니다. 상태 포킹은 가능한 두 가지 시나리오를 명시적으로 고려하기 위해 메모리 할당을 실행한 후에 두 가지 상태를 생성한다(도 6). 분기 상태에 대한 경로 제약 조건은 \(i\)의 값에 대해 이루어진 가정을 인코딩한다. 유사하게, 라인 5에서의 메모리 판독 동작 a[j]는 어레이 인덱스 \(j\)의 알려지지 않은 값에 따라 \(a[0]\) 또는 \(a[1]\ 중 어느 하나에 액세스할 수 있다. 따라서 할당 a[i]=5의 두 가지 가능한 결과 각각에 대해 해당 상태를 포킹하여 명시적으로 탐구하는 주장의 두 가지 가능한 결과가 있다.
* _if-then-else formulas_ 입니다. 대안의 접근법은 기호 포인터의 가능한 값에 대한 불확실성을 기호 저장소에 보관된 식과 기호 저장소에 보관된 식에 인코딩하는 것이다.

도 5. 메모리 모델링 예: i 및 j의 어떤 값이 어써트를 실패하게 하는가?

도 6. 도 5의 예에 대한 상태 포킹을 통한 완전 심볼 메모리.

새로운 상태를 탐색하지 않고 경로 제약 조건 핵심 아이디어는 c가 참이면 t를, 그렇지 않으면 f를 산출하는 형식 \(ite(c,\) t, f)의 if-then-else 식을 포함하는 공식에 대해 추론하는 일부 해결자의 능력을 이용하는 것이다. 접근 방식은 메모리 읽기 및 쓰기 동작에 대해 다르게 작동한다. (a_{1},a_{2},\ldots\)의 구체적인 값을 가정할 수 있는 기호 주소 \(a_{1},a_{2},\ldots\)로 하자. - (\alpha\)에서 읽으면 식 \(ite(\alpha=a_{1},\sigma(a_{1}),ite(\alpha=a_{2},\sigma(a_{2},\ldots))\); - (\alpha\)에서 식 \(e\)을 쓰면 각 \(a_{1},a_{2},\ldots\)에 대한 기호 저장소가 \(\sigma(a_{i})\gets ite(\alpha=a_{i},e,\sigma(a_{i}))\으로 갱신된다. 두 경우 모두 메모리 작업은 액세스된 기호 주소가 가정할 수 있는 가능한 값의 수만큼 \(ite\) 식을 저장소에 도입합니다. 기호 메모리에 대한 \(ite\) 접근법은 예를 들어 Angr[95] (섹션 3.3)에서 사용된다.

**예제.** 그림 5에 표시된 예제를 다시 고려합니다. 4행에서 a[i]=5 작업 후 상태를 포킹하는 대신 if-then-else 접근법은 할당의 가능한 결과, 즉 \(a[0]\mapsto ite(\alpha_{i}=0,5,0)\) 및 \(a[1]\mapsto ite(\alpha_{i}=1,5,0)\)를 모두 인코딩하여 메모리 저장소를 업데이트합니다(그림 7). 마찬가지로, 선 5에서 a[j]의 각 가능한 별개의 주소에 대한 새로운 상태를 생성하기 보다는, \(j\)에 대한 불확실성은 단일 표현식 \(ite(\alpha_{j}=0,\sigma(a[0]),\sigma(a[1])=ite(\alpha_{j}=0,ite(\alpha_{i}=0,5,0),ite(\alpha_{i}=1,5,0))\으로 인코딩된다.

광범위한 연구 라인(예를 들어, EXE[21], KLEE[20], SAGE[43])은 일부 SMT 솔버의 표현력을 활용하여 완전한 기호 포인터를 모델링한다. 배열 이론 _[49]를 사용 하 여 배열 작업은 실제로 제약 조건 수식에서 첫 번째 클래스 엔터티로 표현 될 수 있습니다.

그 일반성으로 인해 완전한 기호 메모리는 가능한 모든 메모리 조작을 설명하는 프로그램의 메모리 동작에 대한 가장 정확한 설명을 지원한다. 많은 실제 시나리오들에서, 메모리 동작이 참조할 수 있는 가능한 어드레스들의 세트는 도 5에 도시된 예에서와 같이 작을 수 있다[98]. 여기서 인덱스 \(i\) 및 \(j\) 범위는 제한된 구간에서 범위이므로, 합리적인 양의 리소스를 사용하여 정확한 분석을 가능하게 한다. 그러나, 일반적으로, 심볼릭 어드레스는 메모리 내의 임의의 셀을 참조할 수 있어, 가능한 상태들의 수에서 난해한 폭발을 초래할 수 있다. 이러한 이유로, 확장성을 개선하기 위해 다수의 기술이 설계되었으며, 이는 다음의 주요 라인을 따라 정교해진다:

* 콘크리트보다는
- 데이터에 대한 주소 식, 컴팩트한 암시적 형식의 기호 주소를 사용하여 메모리를 참조하는 결과 가능한 대체 상태를 나타냅니다. 쿼리는 메모리 판독 동작에 의해 참조될 수 있는 저장된 데이터를 결정하기 위해 효율적인 페이징된 인터벌 트리 구현들로 오프로딩된다.

도 7: 도 5의 예에 대한 if-then-else 공식들을 통한 완전한 심볼 메모리.

* _성능에 대한 건전성 거래_ 이 섹션의 나머지 부분에서 논의된 아이디어는 상징 포인터를 구체적인 주소로 대체하여 실행 상태의 하위 집합으로 상징 탐구를 코르세팅하는 것으로 구성된다.
* _힙 모델링._ 추가 아이디어는 포인터가 null로 제한되는 상태로 탐사를 코르셋하거나 일반 메모리 위치(섹션 3.2 및 섹션 3.4)가 아닌 이전에 힙 할당된 객체를 가리키는 것이다.

### Address Concretization

포인터 값이 충분히 작은 범위로 제한될 수 없기 때문에 분석의 조합 복잡성이 폭발하는 모든 경우에 포인터를 단일 특정 주소로 구체화하는 것으로 구성된 _주소 구체화_가 인기 있는 대안이다. 이것은, 예를 들어, 엔진이 일부 포인터들에 대한 특정 값들에 의존하는 경로들을 놓치게 할 수 있지만, 상태들의 수 및 솔버에 공급된 공식들의 복잡성을 감소시키고 따라서 실행 시간을 개선할 수 있다.

오프라인의 실행자(제2.4절)에서는 당연히 구체화가 발생한다. 눈에 띄는 예는 DART(DART, 2007) 및 CUTE(DBL, 2008)이며, 이는 유형 T*의 레퍼런스를 NULL로, 또는 크기(T) 바이트의 새로 할당된 오브젝트의 어드레스로 구체화하여 메모리 초기화를 처리한다. DART는 무작위로 선택하고 CUTE는 먼저 NULL을 시도한 다음 후속 실행에서 구체적인 주소를 선택한다. T가 구조라면 뾰족한 물체의 모든 필드에 동일한 구체화 접근법이 재귀적으로 적용된다. 메모리 주소(예: malloc에 의해 반환됨)는 서로 다른 구체적인 실행에서 비결정적으로 변경될 수 있으므로 CUTE는 기호 형식에서 _논리 주소_를 사용하여 서로 다른 실행에서 일관성을 유지합니다. 구체화의 또 다른 이유는 제약 해결의 효율성에 기인한다. 예를 들어, CUTE는 등가 그래프를 사용하는 포인터 동일성 제약에만 관한 것으로, 비용이 많이 드는 SMT 이론이 필요한 보다 일반적인 제약에 대한 구체화에 의존한다.

### 부분 메모리 모델링

메이에헴(Mayerhem, 2009)은 완전 심볼 메모리의 확장성 문제와 메모리 구체화의 건전성 손실을 완화하기 위해 _부분 메모리 모델(partial_ memory model)을 도입하여 스펙트럼의 중간점을 탐색한다. 핵심 아이디어는 기입된 어드레스는 항상 구체화되고 판독 어드레스는 그들이 가정할 수 있는 값의 연속 간격이 충분히 작으면 기호적으로 모델링된다는 것이다. 이 모델은 트레이드-오프에 기초한다: 상태당 다수의 포인터 값을 인코딩하기 때문에 구체화보다 더 많은 표현 공식을 사용하지만, 완전히 심볼릭 메모리(DBL, 2008)에서와 같이 이들 모두를 인코딩하려고 시도하지 않는다. 어드레스가 가정할 수 있는 가능한 값들의 집합을 바운딩하기 위한 기본적인 접근법은 서로 다른 구체적인 값들을 시도하고, 엄격한 범위가 발견될 때까지 각 시도에서 어드레스 공간의 큰 부분을 제외하고, 그것들이 현재의 경로 제약들을 만족하는지 여부를 검사하는 것으로 구성된다. 이 알고리즘에는 여러 가지 주의 사항이 있다. 예를 들어, 각 기호 참조에서 해결자를 쿼리하는 것은 비용이 많이 들고, 메모리 범위가 연속적이지 않을 수 있으며, 기호 포인터의 메모리 영역 내의 값은 구조를 가질 수 있다. 따라서 Mayhem은 범위를 효율적으로 정제하기 위해 _value-set analysis_(Mayerhem, 2009) 및 쿼리 캐싱의 형태(섹션 6)와 같은 다수의 최적화를 수행한다. 프로세스의 종료 시에 범위 크기가 주어진 임계치(예를 들어, 1024)를 초과하면, 어드레스가 구체화된다. Angr(Mayer, 2009)는 또한 부분 메모리 모델 아이디어를 채택하고, 작은 연속적인 간격(최대 128 어드레스) 내에서 범위인 심볼릭 포인터에 대한 기입 동작을 선택적으로 지원함으로써 확장한다.

### Lazy Initialization

(Kumar et al., 2017)는 C++ 및 Java에 의해 제공되는 것과 같은 고급 객체 지향 언어 구성에 대한 심볼릭 실행 기술을 제안한다. 본 논문에서는 목록과 트리와 같은 링크된 데이터 구조를 처리하기 위해 심볼릭 실행과 모델 검사를 결합한 소프트웨어 검증 프레임워크를 설명한다.

특히, 동적으로 할당된 객체를 효과적으로 처리하기 위해 _지연 초기화_를 도입하여 심볼릭 실행을 일반화한다. 섹션 1.1의 준비 예제와 비교하여 상태 표현은 이러한 개체를 유지하는 데 사용되는 _힙 구성_으로 확장됩니다. 복잡한 객체를 입력으로 하는 방법의 상징적 실행은 초기화되지 않은 필드로 시작하여 값을 게으른 방식으로 할당하는데, 즉 실행 중에 처음 액세스할 때 초기화된다.

초기화되지 않은 참조 필드가 액세스될 때, 알고리즘은 필드를 (1) 널, (2) 모든 심볼릭 속성을 갖는 새로운 객체에 대한 참조, 및 (3) 각각 원하는 유형의 이전에 도입된 콘크리트 객체로 초기화하는 세 가지 상이한 힙 구성으로 현재 상태를 포크한다.

[66, 107] 게으른 초기화를 사용자 제공 _메소드 전제 조건들_ 즉, 메소드의 실행 전에 참으로 가정되는 조건들과 결합한다. 사전 조건은 방법이 프로그래머가 의도한 대로 작동할 것으로 예상되는 프로그램 입력 상태를 특성화하는 데 사용된다. 예를 들어, 우리는 이진 트리 데이터 구조가 비순환적이고 루트를 제외한 모든 노드에서 정확히 하나의 부모를 가질 것으로 예상한다. 보존적 전제 조건을 사용하여 초기화하는 동안 잘못된 힙 구성이 제거되어 기호 실행 프로세스가 빨라집니다.

**예제.** 그림 8은 연결 된 목록에 유형 노드의 노드를 추가 하는 재귀 Java 메서드 추가 및 지연 초기화를 적용 하는 경우 기호 실행의 최소 표현을 보여 줍니다. 트리 노드는 추가의 직선 단편의 실행을 나타낸다. 초기에, 단편 A는 참조 1을 평가하며, 이는 상징적이며 따라서 초기화되지 않는다. 심볼 엔진은 (1) l은 null, (2) l은 새로운 객체를 가리키고, (3) l은 이전에 할당된 객체를 가리킨다. 유형 노드의 참조가 충족되는 것은 이번이 처음이기 때문에 옵션 (3)은 배제된다. 그런 다음 나머지 두 가지 옵션이 확장되어 관련된 조각을 실행한다. 첫 번째 경로는 단편 B를 실행한 후 끝나는 반면, 두 번째 경로는 지연된 초기화로 인해 암묵적으로 새로운 객체 o\({}_{1}\)를 생성한 후 C를 실행하여 재귀적으로 추가를 호출한다. 재귀적 호출을 확장할 때, 단편 A가 실행되고 엔진에 의해 세 가지 옵션이 다시 고려되며, 이는 세 개의 별개의 경로로 포크된다. 옵션 (3)은 노드 개체가 이전에 할당되었기 때문에(즉, o\({}_{1}\)) 이제 고려된다. 그러나, 이 경로는 비순환성 전제조건(이 예에서 코멘트로 표현됨)을 위반하기 때문에 엔진에 의해 곧 중단된다. 다른 갈림길은 동일한 과정을 반복하면서 더 확장된다. 링크된 리스트는 알려지지 않은 최대 길이를 갖기 때문에, 탐색은 무한정 진행될 수 있다. 이러한 이유로, 구체화(즉, 필드 인스턴스화) 체인의 깊이 상의 상한을 가정하는 것이 일반적이다.

이 분야의 최근 발전은 힙 구성을 생성하는 효율성을 향상시키는 데 초점을 맞추고 있다. 예를 들어, [38]에서 참조 변수의 구체화는 객체가 될 때까지 연기된다

도 8: 게으른 초기화의 예

[MISSING_PAGE_EMPTY:15]

상징 분기 조건이 평가되고, 실행 엔진은 에뮬레이터의 병렬 인스턴스를 포킹하여 대체 경로를 탐색한다. 선택적 심볼릭 실행(섹션 2.1)은 전체 솔루션의 확장성을 상당히 제한할 수 있는 전체 스택(예를 들어, 사용자 코드, 라이브러리, 드라이버)을 에뮬레이트하는 오버헤드를 부분적으로 완화하면서 소프트웨어 스택 전반에 걸친 심볼릭 탐색의 범위를 제한하는 데 사용된다.

자동화된 단위 테스트가 가능하도록 하는 것이 목표이기 때문에 DART의 접근 방식(DART, 2018)은 다르다. DART는 최상위 함수에 대한 인수와 함께 C 프로그램에서 참조되는 모든 외부 변수 및 함수를 외부 인터페이스로 간주한다. 외부 함수는 지정된 반환 유형의 값을 비결정적으로 반환함으로써 시뮬레이션된다. 환경에 의존하지 않는 라이브러리 함수의 기호 탐색을 허용하기 위해, 사용자는 외부 함수와 비외부 함수의 경계를 조정하여 기호 분석의 범위를 조정할 수 있다.

### Application Environment

이제 분석 중인 프로그램을 대신하여 제어 및 데이터 흐름을 수행하는 소프트웨어 요소를 처리하기 위한 가능한 솔루션에 대해 논의한다. 이러한 문제의 인스턴스는 예를 들어, 사용자 상호작용 동안 애플리케이션 코드(예를 들어, 콜백을 통해)를 호출하기 위한 추상 설계를 구현하는 스윙 및 안드로이드와 같은 프레임워크에서 발생한다(스윙 및 기타, 2018). 기호 값은 관리되는 런타임에서 실행되는 애플리케이션(예: 네이티브 Java 메서드 또는 NET(Bahdan 등, 2018)에서 관리되지 않는 코드를 호출할 때)에 대해서도 분석의 경계 밖으로 흐릅니다. 그러한 특징들은 엔진의 구현을 복잡하게 한다: 예를 들어, Java에서의 네이티브 방법들 및 반사는 기본 JVM의 내부들에 의존한다(Bahdan 등, 2018). 폐쇄된 소스 구성요소는 이 문제의 또 다른 사례를 나타낼 수 있다.

시스템 환경 모델링에서와 유사하게, DART(DART, 2018) 및 CUTE(DART, 2018)와 같은 초기 작업은 다른 소프트웨어 컴포넌트에 대한 호출을 구체적인 인수로 실행함으로써 처리한다. 이는 불완전한 탐색을 초래하여 실현 가능한 프로그램 경로에 대한 테스트 입력을 생성하지 못할 수 있다. 다른 한편으로, 그들의 코드의 상징적 실행은 다수의 이유로 성공할 것 같지 않다: 예를 들어, 외부 단순 행동의 구현은 확장성 및 유지성을 허용해야 하기 때문에 종종 복잡하거나, 콜백을 트리거하는 버튼을 디스플레이하는 방법(스윙 및 기타, 2018)과 같은 탐색과 무관한 세부 사항을 포함할 수 있다. 한 가지 해결책은 더 간단하고 추상적인 모델로 외부 구성 요소를 모방하는 것이다. 그러나 소스 코드를 사용할 수 없기 때문에 복잡한 작업 자체가 될 수 있는 컴포넌트 모델을 수동으로 작성하는 것은 어려울 수 있으며 지원되지 않는 모델을 사용하는 응용 프로그램은 손이 닿지 않는 상태로 남아 있다.

일부 작업들(예를 들어, (바단 등, 2018; DART, 2018))은 컴포넌트로부터 어떤 엔티티들이 심볼 탐색에서 심볼 값들을 보유할 수 있는지를 정확히 지적하기 위한 기법들을 탐색하고, 따라서 이들의 분석을 위해 인간의 개입(예를 들어, 모델 작성)을 요구한다. 다른 연구 라인에서 대신 모델을 자동으로 생성하려고 시도했는데, 이는 폐쇄 소스 구성요소에 대한 유일한 실행 가능한 옵션일 수 있다. (DART, 2018; DART, 2018)은 프로그램 슬라이싱을 사용하여 분석과 관련된 주어진 필드 집합을 조작하는 코드를 추출하고 그로부터 추상 모델을 구축한다. (스윙 및 기타, 2018)는 프로그램 합성을 사용하여 Java 프레임워크에 대한 모델을 생성함으로써 한 단계 더 나아간다. 그러한 모델들은 많은 프레임워크들에서 많이 사용되는 디자인 패턴들의 동등한 인스턴스화를 제공한다: 이것은 심볼릭 실행기들이 그렇지 않으면 놓치게 될 관찰자 패턴을 통해 사용자 코드에 대한 콜백들과 같은 제어 흐름을 발견하는 것을 돕는다. 프로그램 합성을 사용하는 장점은 프로그램의 기능적 행동을 포착하여 프로그램이 작성되는 방법의 세부 사항과 얽힘을 추상화하기 때문에 슬라이싱보다 더 간결한 모델을 생성할 수 있다는 것이다.

## 5. 경로 폭발

심볼 실행의 주요 과제 중 하나는 경로 폭발 문제이다. 심볼 실행기는 프로그램의 모든 분기마다 새로운 상태를 분기할 수 있으며, 총 상태 수는 분기 수에 쉽게 지수화할 수 있다. 탐구해야 할 많은 보류 분기를 추적하는 것은 차례로 상징 실행기의 실행 시간과 공간 요구 사항 모두에 영향을 미친다.

경로 폭발의 주요 원인은 루프와 함수 호출이다. 루프의 각 반복은 if-goto 문으로 볼 수 있으며, 실행 트리에서 조건부 분기로 이어진다. 루프 조건이 하나 이상의 심볼릭 값을 포함하는 경우, 다음의 예에 의해 제안된 바와 같이, 생성된 브랜치의 수는 잠재적으로 무한할 수 있다.

**예제.** 다음 코드 조각(Krishnan, 2018)을 고려합니다.

```
intx=sym_input();//e.g.,readfromfile while(x>0)x=sym_input();
```

wheresym_input()는 (예를 들어, 네트워크로부터 입력 데이터를 판독함으로써) 환경과 상호작용하고 새로운 심볼릭 입력을 반환하는 외부 루틴이다. 임의의 최종 상태에서 설정된 경로 제약 조건은 다음의 형태를 갖는다:

\[\pi=\left(\bigwedge_{i\in[1,k]}\alpha_{i}>0\right)\wedge(\alpha_{k+1}\leq 0)\]

여기서, \(k\)은 반복의 횟수이고, \(\alpha_{i}\)은 \(i\)-번째 반복에서 sym_input()에 의해 생성된 심볼이다.

루프 탐사를 제한된 반복 횟수로 제한하는 것은 간단하지만(그리고 실제로 일반적이지만), 이 접근법으로 흥미로운 경로를 쉽게 놓칠 수 있다. 따라서 많은 연구가 코드 부분의 반복적인 탐색을 방지하는 요약 전략을 통해 별개의 루프 반복 또는 함수 호출에 걸쳐 유사성을 특성화하거나 계산의 특성을 귀납적으로 설명하는 불변량을 추론함으로써 보다 진보된 전략을 탐구했다. 이 섹션의 나머지 부분에서 우리는 종종 상태 공간의 관련 부분 집합만 탐구하기 위한 목적으로 분석의 과소 근사 계산을 기반으로 하는 다양한 두드러진 기술을 제시한다.

### 실행 불가능한 경로 프루닝

경로 공간을 줄이기 위한 첫 번째 자연 전략은 제약 해법을 각 분기마다 호출하고, 실현 불가능한 분기들을 가지치기하는 것이다. 만약 해법이 한 분기의 경로 제약에 의해 주어진 논리식이 만족스럽지 않다는 것을 증명할 수 있다면, 프로그램 입력 값의 할당은 그 경로를 향해 실제 실행을 유도할 수 없으며, 이는 건전성에 영향을 주지 않고 상징 엔진에 의해 안전하게 폐기될 수 있다. 이 전략의 예는 그림 9에 나와 있다.

이 접근 방식은 제약 조건이 각 분기에서 열렬히 확인되고 일반적으로 대부분의 기호 엔진에서 기본값이기 때문에 일반적으로 경로 제약 조건의 _최소 평가_ 라고 합니다. 제약 조건 해결사의 부담을 줄이기 위한 반대 전략인 _지연 평가_에 대한 논의는 섹션 6을 참조한다.

확인할 경로의 수를 줄이는 데 도움이 될 수 있는 직교 접근법이 (크리시난, 2018)에 제시되어 있다. SMT 해결기는 한 번에 하나의 경로를 탐색하는 데 사용될 수 있지만, 종종 많은 경로들에 의해 공유되는 제어 흐름들에 대한 추론이 끝날 것이다. 이 관찰을 이용한 작업

그림 9. 실현 불가능한 경로 제거 예제: (a) 코드 조각; (b) 코드 조각의 상징적 실행: 노드 D에서 _true_ 브랜치는 경로 제약 조건(\(\alpha_{a}\leq 0\wedge\alpha_{a}>1\))이 만족스럽지 않기 때문에 탐색되지 않는다.

불만족으로 판명된 각 경로에서 최소 _unsat core_를 추출하여 불만족을 유지하면서 가능한 한 많은 문을 제거합니다. 따라서 엔진은 충족되지 않는 코어를 사용하여 동일한(만족스럽지 않은) 문을 공유하는 경로를 폐기할 수 있습니다.

### 함수 및 루프 요약

코드 조각 (함수 또는 루프 본문)이 여러 번 횡단 되는 경우 기호 실행기는 후속 재사용을 위해 실행의 요약을 빌드할 수 있습니다.

함수 요약 함수 \(f\)는 동일한 호출 컨텍스트 또는 다른 호출 컨텍스트에서 실행 전체에 걸쳐 여러 번 호출될 수 있습니다. 각 호출에서 \(f\)을 기호적으로 실행 하는 일반 실행기와는 달리 Concolic 실행기에 대해 [50]에서 제안 된 구성 접근 방식은 _함수 요약_ 을 동적으로 생성 하 여 실행기가 이전에 검색 된 분석 결과를 효과적으로 재사용할 수 있습니다. 이 기법은 함수 호출의 효과를 포뮬러 \(\phi_{w}\)로 포착하여 경로 탐색 동안 관찰된 함수 입력에 대한 제약 조건을 결합하여 구체적인 실행의 동등성 클래스를 설명하고 출력에 대한 제약 조건을 설명한다. 입력들 및 출력들은 액세스된 메모리 위치들의 관점에서 정의된다. 함수 요약은 \(\phi_{w}\) 공식을 서로 다른 클래스에서 분리하는 명제 논리 공식이며, 실행 가능한 절차 간 경로는 절차 내 공식의 상징적 실행을 구성하여 모델링한다. [4] 해석되지 않은 함수와 함께 1차 논리 공식으로 요약을 생성하여 구성적 기호 실행을 확장함으로써 더 많은 진술이 다루어짐에 따라 절차 간 분석 동안 수요에 따라 확장될 수 있는 불완전한 요약(즉, 함수 내 경로의 하위 집합만 캡처)을 형성할 수 있다.

[14] 다음의 직관에 기초하여 요약의 다른 풍미를 탐구한다 : 두 상태가 나중에 판독되지 않는 일부 프로그램 값에 대해서만 다르면, 두 상태에 의해 생성된 실행은 동일한 부작용을 생성할 것이다. 따라서 코드 조각의 부작용은 캐시되고 나중에 재사용될 수 있다.

루프 요약.함수 호출과 유사하게, 루프에 대한 부분 요약은 [54]에 설명된 바와 같이 얻어질 수 있다. 루프 요약은 루프 조건과 심볼 변수 사이의 종속성에 대한 추론에 의해 심볼 실행 중에 동적으로 계산되는 사전 및 사후 조건을 사용한다. 루프 요약을 캐싱하는 것은 심볼릭 엔진이 동일한 프로그램 상태에서 동일한 루프의 중복 실행을 피할 수 있게 할 뿐만 아니라, 상이한 조건 하에서 동일한 루프의 상이한 실행을 커버하도록 요약을 일반화하는 것을 가능하게 한다.

초기 작업은 고정 양을 추가 하 여 반복에 걸쳐 기호 변수를 업데이트 하는 루프에 대해서만 요약을 생성할 수 있습니다. 또한 중첩 루프 또는 _다중 경로 루프_ 즉, 본문 내에 분기가 있는 루프를 처리할 수 없습니다. 프로테우스 [113]은 다중 경로 루프를 요약하기 위해 제안된 일반적인 프레임워크이다. 경로 조건들(즉, 유도 변수의 업데이트 여부) 및 루프 내의 경로들의 인터리빙의 값들의 패턴들(즉, 규칙성의 존재 여부)에 따라 루프를 분류한다. 분류는 확장된 형태의 제어 흐름 그래프를 활용하며, 이 그래프는 인터리빙을 모델링하는 오토마타를 구성하는 데 사용된다. 오토마타는 깊이 우선 방식으로 횡단되고 그 안에 있는 모든 실행 가능한 자취에 대해 분리 요약이 구성되며, 여기서 자취는 루프에서 실행을 나타낸다. 분류는 루프가 정확하게 또는 대략적으로 캡처될 수 있는지(여전히 실질적인 관련성이 있을 수 있음), 또는 그렇지 않을 수 있는지를 결정한다. 불규칙한 패턴 또는 비귀납적 업데이트가 있는 다중 경로 루프의 정확한 요약, 더 중요한 중첩 루프의 요약은 여전히 열린 연구 문제로 남아 있다.

다른 풍미의 것은 [96]에 소개된 압축 기술이며, 여기서 제어 흐름 그래프에서 순환 경로의 분석은 코드의 일부에 의해 생성된 프로그램 상태를 선언적으로 _컴팩트_ 심볼릭 실행 트리로서 기술하는 _templates_를 산출한다. 템플릿들을 이용함으로써, 심볼릭 실행 엔진은 상당히 감소된 수의 프로그램 상태들을 탐색할 수 있다. 이 접근법의 단점은 템플릿이 경로 제약에 양자화기를 도입한다는 것인데, 이는 차례로 제약 솔루션에 대한 부담을 상당히 증가시킬 수 있다.

### 경로 포함 및 동등성

큰 상징 상태 공간은 예를 들어 새로운 발견으로 이어질 수 없는 경로를 폐기하거나 수익성이 있을 때 차이를 추상적으로 제거하는 것과 같은 경로 유사성을 탐색하는 기술의 범위를 제공한다. 이 섹션에서는 이러한 선을 따라 여러 작업에 대해 논의한다.

**보간**: 현대 SAT 해결사는 검색 및 연산의 상호 강화 조합에 의존하며, 후자를 사용하여 전자가 차단되면 충돌에서 멀어지게 합니다. 유사한 방식으로 기호 실행은 원하는 속성을 표시 하지 않는 프로그램 경로에서 속성을 파생 하는 _보간_ 기술의 이점을 얻을 수 있으므로 이를 충족 하지 않는 유사한 경로의 탐색을 방지할 수 있습니다.

_Craig interpolants_(Steiner, 2018)는 수식에 대한 어떤 정보가 속성과 관련되는지 결정할 수 있게 한다. 어떤 논리에서는 함축적인 \(P\to Q\)이 성립한다고 가정하면, \(P\to I\)과 \(I\to Q\)이 유효하도록 보간법 \(I\)을 구성할 수 있으며, \(I\)의 모든 논리는 \(P\)과 \(Q\) 모두에서 발생한다. 프로그램 검증에서 보간법(Interpolation)은 다음과 같이 일반적으로 사용된다. 만족스럽지 못한 수식 \(P\wedge Q\)에 대한 반박 증명이 주어졌을 때, \(P\to I\)이 유효하고 \(I\wedge Q\)이 만족스럽지 않도록 _역 보간법 \(I\)_을 구성할 수 있다.

보간은 모델 확인, 술어 추상화, 술어 정제, 정리 증명 및 기타 영역에서 주로 사용되었다. 예를 들어 보간 프로그램은 _경계 모델 검사_ 를 확장 하는 방법론을 제공 합니다. - 전이 관계가 지정 된 경계로 롤링 되는 프로그램의 안전 특성을 변경 하는 것을 목표로 합니다. - 경계 되지 않은 경우입니다. 특히, 바운딩된 증명들은 종종 바운딩되지 않은 증명들의 성분들을 포함하기 때문에, 보간은 바운딩된 경우에 대한 반박 증명으로부터 도달가능한 모든 최종 상태들의 과근사를 구성하는 것을 도울 수 있어서, 위반들의 부재를 증명하기에 충분히 강한 과근사를 획득한다.

**보간을 사용 하 여 추정**: 보간은 명시적 오류 위치를 사용 하 여 표시 된 (예: 어설션을 사용) 프로그램을 기호적으로 확인 하는 경우 경로 폭발 문제를 해결 하는 데 사용할 수 있습니다. 탐사가 진행됨에 따라 엔진은 오류 위치에 도달하지 못한 이전 경로를 요약한 조건으로 각 프로그램 위치에 주석을 달게 된다. 분기가 발생할 때마다 실행자는 경로 조건이 이전 탐색에 포함되는지 여부를 확인합니다. 최상의 시나리오에서, 이 접근법은 방문 경로의 수를 기하급수적으로 감소시킬 수 있다.

[(75)]는 분기 및 문에 대한 주석 알고리즘을 제안하여, 그들의 라벨이 현재 상태에 의해 암시되면, 오류 위치로 이어질 수 없도록 한다. 내삽은 암시를 효율적으로 계산할 수 있는 약한 레이블을 구성하는 데 사용된다. [(117)]은 포스트컨디셔닝된 심볼릭 실행_이라고 불리는 유사한 중복 제거 방법을 제안하며, 여기서 프로그램 위치들은 포스트컨디셔닝, 즉 이전 탐색들로부터 나온 "가장 약한 프리컨디셔닝" 요약 경로 접미사로 주석 처리된다. 여기서 직관은 보간제가 약할수록 경로 포집을 가능하게 할 가능성이 높다는 것이다. 후조건은 완전히 탐색된 경로로부터 점진적으로 구성되고 뒤로 전파된다. 분기가 마주쳤을 때, 대응하는 사후 조건은 부정되고 경로 제약에 추가되며, 경로가 이전 탐색에 의해 포섭되면 만족스럽지 않게 된다.

경로 포섭의 건전성은 위치에 대해 계산된 보간제가 경로를 통과하는 경로의 전체를 포착한다는 사실에 의존한다. 따라서, 경로 선택 전략은 보간제 구축을 가능하게 하는 데 핵심적인 역할을 한다: 예를 들어, DFS는 경로를 빠르게 탐색할 수 있기 때문에 매우 편리하여 보간제가 구축될 수 있고 결국에는 후방으로 전파될 수 있다; BFS는 대신에 유사한 경로가 아직 완전히 탐색되지 않았기 때문에 분기들에서 중복성을 체크할 때 보간제가 이용 가능하지 않을 수 있기 때문에 포섭을 방해한다. [59] 내삽 형성에서 경로 선택 문제를 제거 하 여 사용자가 DFS 이외의 휴리스틱을 사용할 때 경로 포섭의 이점을 얻을 수 있도록 하는 _탐욕 확인_ 이라는 새로운 전략을 제안 합니다. 탐욕적 확인은 경로의 트리가 전체 또는 부분적으로 탐색된 노드를 구별하며, 후자의 경우 보간제 형성을 가능하게 하기 위해 추가 경로의 제한된 횡단을 수행한다.

보간은 주어진 시간 예산 내에서 복잡한 프로그램의 더 큰 부분을 탐색할 수 있도록 하는데 유용한 것으로 입증되었다. [117] 경로 중복성은 실제 응용에서 풍부하고 널리 퍼져 있다고 주장한다. 전형적으로, SMT 해결기 내에서 또는 전용 엔진에서 수행될 수 있는 보간 오버헤드는 초기 단계에서 탐사를 느리게 하고, 그 이득은 결국 성과를 내기 시작하여 훨씬 더 빠른 탐사를 가능하게 한다[59].

제한되지 않은 루프 코드 내의 제한되지 않은 루프의 존재는 매우 많은 수의 경로들이 그들을 통과할 수 있기 때문에 그 내의 프로그램 위치들에서 사운드 포집을 수행하는 것을 더 어렵게 한다. [75] 고정된 깊이까지 루프를 롤링하고 _루프 불변_ 인 보간자를 계산 하 여 제한 되지 않은 경우 오류 노드의 도달 불가능을 증명 하는 데 사용할 수 있도록 반복 심화 전략을 고안 합니다. 그러나 이 방법은 분리 루프 불변수가 필요한 프로그램에 대해서는 종료하지 않을 수 있다. [61] 따라서 루프의 상징적 실행이 빠르게 수렴할 수 있을 만큼 충분히 강력하지만 가능한 한 경로 포집을 허용할 만큼 충분히 느슨한 추측 불변량을 계산하는 전략을 제안한다. 후속 작업에서 [60] 루프 불변은 확장 연산자를 사용하여 기호 실행 중에 별도로 발견되고 경로 포섭에 대한 가장 약한 전제 조건은 불변으로 수반되도록 구성된다.

우리는 [62]에서 제안된 이 설정에서 추상적 해석을 사용하는 아이디어가 다른 프로그램 검증 기술에서 많은 응용 프로그램의 이점을 얻을 수 있고 구성된 불변수가 오류 노드의 (비)신뢰성을 포착할 만큼 정확하다면 주류 상징 실행기에서 효율적인 구현에 적합하기 때문에 추가 조사가 필요하다고 믿는다.

Abstraction을 사용한 추정 보간법에 기초하지 않는 접근법이 [6]에서 취해지는데, 이는 심볼 상태들에 대한 이중 포섭 체크 기술을 설명한다. 기호 상태는 상징 힙과 스칼라 변수에 대한 제약 조건의 집합으로 정의된다. 따라서, 이 기술은 스칼라 타입뿐만 아니라, 초기화되지 않거나 부분적으로 초기화된 데이터 구조를 조작하는 프로그램들을 대상으로 한다. 그래프 탐색을 통해 힙 구성을 일치시키는 알고리즘을 제시하고 스칼라 데이터에 대한 포섭을 추론하기 위해 기성 해법을 사용한다.

제한되지 않은 상태 수에 대처하기 위해, 이 연구는 상징 상태 공간을 유한하게 만들고 따라서 포섭을 효과적으로 만들기 위한 추상화를 제안한다. 추상화는 스칼라 데이터의 힙 모양과 제약 조건을 모두 요약할 수 있으며, 링크된 목록 및 배열에 대한 예가 제공됩니다. 추정 체크는 과소 근사 상태에서 발생하며, 이는 실현 가능한 행동을 놓칠 수 있음을 의미한다. 저자는 모델 확인과 함께 변조 시나리오에서 이 기술을 사용하여 기호 실행만을 기반으로 한 검증에 응용 프로그램을 맡긴다.

제어 및 데이터 흐름에 대한 경로 분할 종속성 분석은 추가 프로그램 동작을 드러낼 수 없는 경로를 필터링하기 위해 탐색 동안 사용할 수 있는 인과 관계를 노출한다. [74] 비간섭 블록에서 콘콜릭 실행을 위한 파티션 입력은 각 블록을 상징적으로 탐색하고 다른 블록은 구체적인 값에 고정된다. 두 입력의 간섭은 하나의 문, 또는 제어 또는 데이터 종속성에 의해 링크된 문에 공동으로 영향을 줄 때 발생한다. [84] 프로그램 출력과 관련하여 동일한 관련 슬라이스가 있는 경우 동일한 파티션에 두 개의 경로를 배치하여 출력에 초점을 맞춥니다. 관련 슬라이스는 동적 데이터 및 제어 종속성의 추이적 폐쇄, 또한 실행되지 않음으로써 출력에 영향을 미치는 문과 관련된 잠재적 종속성이다. (Kumar et al., 2018) 또한, 개별적인 진술들에 대한 관련 슬라이스들을 구축함으로써, 그것들이 기호 입력들로부터 계산되는 방법을 캡처함으로써 출력과 무관한 결함들을 탐구한다. 종속성 분석은 모든 문 인스턴스에 대한 슬라이스가 집합적으로 이전 경로에 의해 커버될 때 중복되는 경로를 간주하여 슬라이스의 동등성을 효율적으로 검사한다.

### 제한 되지 않은 Symbolic 실행

경로 폭발을 피하기 위한 가능한 접근법은 분석할 코드, 예를 들어 함수를 둘러싸는 시스템에서 잘라내고 격리된 상태에서 확인하는 것이다. 사용자가 지정한 전제조건을 갖는 지연 초기화(섹션 3.4)는 복잡한 데이터 구조를 자동으로 재구성하기 위해 이 원리를 따른다. 그러나, 애플리케이션으로부터 코드 영역을 빼는 것은 주변 환경과의 얽힘으로 인해 상당히 어려울 수 있다(Levy 등, 2017): 고립된 상태에서 분석된 함수에서 검출된 오류는 오탐일 수 있는데, 그 이유는 함수가 풀 프로그램의 컨텍스트에서 실행될 때 입력이 결코 특정 값을 가정하지 않을 수 있기 때문이다. 예를 들어, 일부 선행 작업들, 예를 들어 (Levy et al., 2017)은 먼저 고립된 상태에서 코드를 분석한 다음, 거짓 긍정을 걸러내기 위해 콘크리트 실행을 사용하여 생성된 크래싱 입력들을 테스트한다.

_Under-constrained 심볼릭 실행_(Levy et al., 2017)은 심볼릭 입력뿐만 아니라 그의 실행에 영향을 미칠 수 있는 임의의 글로벌 데이터를 _under-constrained_처럼 표시함으로써 고립된 함수의 분석을 허용하는 심볼릭 실행에 대한 트위스트이다. 직관적으로 기호 변수는 분석에서 프로그램의 진입점에서 함수까지의 경로 접두사를 따라 수집되어야 하는 값에 대한 제약을 고려하지 않을 때 과소 제약된다. 실제로, 심볼릭 엔진은 메모리 액세스를 추적하고 그 위치를 식별함으로써 수동 개입 없이 데이터를 과소 제약된 것으로 자동으로 표시할 수 있다: 예를 들어, 스택 상에 위치된 초기화되지 않은 데이터에 대해 메모리 판독이 수행될 때 함수의 입력이 검출될 수 있다. 제약 조건이 낮은 변수는 오류를 생성할 수 있는 표현식에 사용되는 경우를 제외하고는 고전적인 완전히 제약된 기호 변수와 동일한 의미론을 갖는다. 특히, 에러는 변수에 대한 현재 알려진 제약들에 대한 모든 솔루션들이 그것이 발생하도록 야기하는 경우에만 보고된다. 즉, 에러는 문맥에 둔감하고 따라서 진정한 포지티브이다. 그렇지 않으면 해당 부정이 경로 제약 조건에 추가되고 실행이 정상으로 재개됩니다. 이 접근법은 코드에 삽입된 검사로부터 전제 조건을 재구성하려는 시도로 간주될 수 있으며, 추가된 부정 제약 조건을 위반하는 후속 조치는 오류로 보고될 것이다. 이 분석을 올바르게 유지하려면 모든 식이 과소 및 완전히 제한된 값을 모두 포함할 때마다 변수 간에 표시가 전파되어야 합니다. 예를 들어, \(a\)이 구속되지 않은 형태와 \(b\)이 구속되지 않은 형태의 비교는 오염된 값을 처리할 때 오염 분석에서와 유사하게 엔진이 \(a\)에서 \(b\)으로 마크를 전파하도록 강제한다. 마크들은 일반적으로 섀도 메모리를 사용하여 심볼릭 엔진에 의해 추적된다.

이 기술은 오류를 놓칠 수 있기 때문에 건전하지 않지만 더 큰 프로그램에서 흥미로운 버그를 찾기 위해 여전히 확장할 수 있다. 또한, 과소 제약된 심볼릭 실행의 적용은 기능에만 한정되지 않는다: 예를 들어, 코드 영역(예를 들어, 루프)이 심볼릭 실행자에게 번거로울 수 있는 경우, 그것이 과소 제약된 것으로 영향을 미치는 위치들을 표시함으로써 스킵될 수 있다. 일반적으로 일부 스킵된 코드의 실행에 의해 어떤 데이터가 영향을 받을 수 있는지 이해하는 것이 쉽지 않기 때문에 분석을 올바르게 유지하기 위해 수동 주석이 필요할 수 있다.

### 사전 조건 및 입력 기능 사용

경로 폭발을 줄이는 또 다른 방법은 일부 입력 속성에 대한 지식을 활용하는 것이다. AEG(Beng et al., 2017)는 사전 조건 술어를 만족시키는 입력 공간의 서브세트로 탐색을 지시함으로써 탐색된 상태들의 수를 감소시키기 위해 _사전 조건된 심볼릭 실행_을 제안한다. 이 근거는 프로그램의 특정 거동으로 이어질 수 있는 입력(예를 들어, 잠재적인 버퍼 오버플로우를 드러내기 위해 탐색을 최대 크기의 입력으로 좁히는 것)에 초점을 맞추는 것이다. 사전 조건화된 상징 실행은 성능에 대한 건전성을 거래합니다: 잘 설계된 사전 조건은 너무 구체적이지 않아야 합니다(흥미로운 경로를 놓치거나) 너무 일반적이어야 합니다(공간 상태 감소로 인한 속도 향상을 손상시킵니다). 빈 경로 제약 조건 집합에서 시작 하는 대신 사전 조건을 초기 \(\pi\)에 추가 하 여 나머지 탐사가 충족 되지 않는 분기를 건너뜁니다. 초기화 시간에 \(\pi\)에 더 많은 제약 조건을 추가하면 각 분기마다 더 많은 수의 검사를 수행해야 하는 해결사의 부담이 증가할 수 있지만, 이는 더 작은 상태 공간으로 인한 성능 이득에 의해 크게 가중될 수 있다.

기호 실행에서 고려되는 일반적인 사전 조건 유형은 _known-length_ (즉, 버퍼의 크기가 알려져 있음), _known-prefix_ (즉, 버퍼에 알려진 접두사가 있음), _fully known_ (즉, 버퍼의 내용이 완전히 구체화되어 있음)입니다. 이들 전제 조건들은 스트링 파서들 또는 패킷 프로세싱 툴들과 같은 잘 알려진 또는 미리 정의된 구조를 갖는 입력들을 통해 동작하는 코드를 다룰 때 오히려 자연스럽다.

**예제** 다음의 단순화된 패킷 헤더 처리 코드를 고려한다 : pkt는 입력 버퍼를 가리키고, 반면에 헤더는 고정된 예상 컨텐츠로 가리킨다. 사전 조건이 고려되지 않으면, 임의의 불일치가 새로운 호출을 get_input으로 강제하기 때문에 이 코드는 지수 수의 경로를 생성할 수 있다. 반면에 입력에 _알려진 prefix_ 전제 조건이 설정 된 경우 루프를 탐색할 때 단일 경로만 생성 됩니다. 따라서 엔진은 파스_페이로드(parse_payload())에 자신의 탐색을 집중할 수 있다.

다른 풍미는 [88]의 작업으로, 입력 프로그램을 설명하는 문법을 사용할 수 있을 때마다 루프를 효과적으로 탐색할 수 있는 _루프 확장 기호 실행_이라는 기술을 제시한다. 프로그램 입력의 특징들과 반복 횟수를 연관시키는 것은 루프에 의해 생성된 프로그램 상태들의 탐구를 유익하게 안내하여, 경로 폭발 문제를 감소시킬 수 있다.

### State Merging

상태 병합은 서로 다른 경로를 하나의 상태로 융합하는 강력한 기법이다. 병합된 상태는 개별 상태를 별도로 유지했을 경우 개별 상태를 설명한 공식의 분리를 나타내는 공식에 의해 설명된다. 추상적 해석과 같은 다른 정적인 프로그램 분석 기법과는 달리 상징적 실행에서의 병합은 과근사로 이어지지 않는다.

**예제** 아래에 표시된 함수 foo와 그림 9(a)에 표시된 기호 실행 트리를 고려한다. 초기(실행 상태 \(A\)) 경로 제약 조건은 _true_이고 입력 인수 x 및 y는 각각 기호 값 \(\alpha_{x}\) 및 \(\alpha_{y}\과 연관된다. 2행의 조건 분기로 인해 포킹한 후, 다른 문장이 평가되고 심볼 \(\alpha_{x}\)(상태 \(B\) 및 \(C\)에 대해 각각 다른 가정이 이루어진다. 6행의 반환이 결국 모든 분기에 도달하면 기호 실행 트리는 \(D\) 및 \(E\)의 두 가지 추가 상태로 채워집니다. 활성 상태의 수를 줄이기 위해, 심볼릭 엔진은 상태 병합을 수행할 수 있다. 예를 들어, 도 9(b)는 라인 6에서 반환을 평가하기 전에 상태 병합 동작이 수행될 때 동일한 코드에 대한 심볼릭 실행 DAG를 도시한다. \(D^{\prime}\)은 _ite_ 표현 \(ite(\alpha_{x}<5,2*\alpha_{y},3*\alpha_{y})\)을 사용하여 이전의 실행 상태 \(D\) 및 \(E\)를 완전히 캡처하는 병합된 상태이다(섹션 3.1). 실행 상태 \(D\)와 \(E\)의 경로 제약은 분리 공식 \(\alpha_{x}<5\lor\alpha_{x}\geq 5\)으로 병합된 후 \(D^{\prime}\)에서 \(true\)으로 단순화될 수 있다.

**Tradeoff: to Merge or Not to Merge?** 원칙적으로 동일한 문을 평가하려는 두 개의 기호 상태가 기호 저장소에서 매우 유사할 때(즉, 소수의 요소에 대해서만 다를 때) 상태 병합을 적용하는 것이 유리할 수 있습니다. 두 상태 \((stmt,\ \sigma_{1},\ \pi_{1})\)와 \((stmt,\ \sigma_{2},\ \pi_{2})\)가 주어졌을 때, 병합된 상태는 \((stmt,\ \sigma^{\prime},\ \pi_{1}\lor\pi_{2})\)로 구축될 수 있다. 여기서 \(\sigma^{\prime}\)은 \(\sigma_{1}\)과 \(\sigma_{2}\) 사이의 병합된 상징 저장소로 저장의 차이를 고려한 식들로 구축되는 반면, \(\pi_{1}\lor\pi_{2}\)은 두 병합된 상태로부터의 경로 제약의 결합이다. (이전 예에서와 같이) if-else 진술들 또는 단순 루프들과 같은 제어-흐름 구조들은 종종 상태 병합을 위한 매우 양호한 후보들을 나타내는 다소 유사한 후속 상태들을 산출한다.

초기 작업들[50, 57]은 병합 기술들이 탐색할 경로들의 수를 효과적으로 감소시키지만, 제약들 해결자들에 부담을 주는 것을 보여주었고, 이는 접속들에 의해 방해될 수 있다. 병합은 또한, 예를 들어 조건 할당으로부터의 상이한 구체적인 값들을 조건에 걸쳐 심볼 표현식으로 병합할 때, 코드에 새로운 심볼 표현식을 도입할 수 있다. [70] 상태 병합 기법들의 설계 공간에 대한 우수한 논의를 제공한다. 스펙트럼의 한쪽 끝에서, 탐색 기반 심볼릭 실행에서 사용되는 경로들의 완전한 분리(섹션 2.2)는 병합을 수행하지 않는다. 다른 쪽 끝에서, 정적 상태 병합은 제어-흐름 조인 포인트들에서의 상태들을 결합하며, 본질적으로 단일 공식을 갖는 전체 프로그램을 나타낸다. 정적 상태 병합은 전체-프로그램 검증 조건 생성기들[10, 114])에서 사용된다. 일반적으로 루프를 한 번만 풀어서 확장성을 위해 정밀도를 거래합니다.

**휴리스틱 병합** 중간 병합 솔루션은 휴리스틱을 채택 하 여 탐색 프로세스의 속도를 높일 수 있는 상태 병합을 식별 합니다. 실제로, 더 큰 심볼 표현들을 생성하고 아마도 여분의 해결사 호출들을 생성하는 것은 더 적은 상태들을 갖는 것의 이점보다 더 클 수 있고, 더 나쁜 전체 성능으로 이어질 수 있다[57, 70]. _ 쿼리 카운트 추정_[70]은 CFG 내의 임의의 주어진 지점을 지나는 분기 조건들에서 각각의 변수가 얼마나 자주 사용되는지를 식별하기 위해 간단한 정적 분석에 의존한다. 추정치는 주어진 변수가 일부일 가능성이 있는 솔버 쿼리 수에 대한 프록시로 사용된다. 두 상태는 다른 변수가 나중에 쿼리에서 자주 나타나지 않을 것으로 예상되는 경우 병합을 위한 좋은 후보가 됩니다. _ Veritesting_[9]은 쉬운 문과 어려운 문 사이의 구별에 기초하여 휴리스틱을 병합하는 형태를 구현하며, 여기서 후자는 정확한 정적 분석을 달성하기 어려운 간접 점프, 시스템 호출 및 기타 연산을 포함한다. 정적 병합은 \(ite\) 식을 사용하여 효과가 포착된 쉬운 문들의 시퀀스에 대해 수행되고, 경로당 기호 탐색은 분석하기 어려운 문들이 발견될 때마다 수행된다.

**동적 상태 병합.** 병합 기회를 최대화 하기 위해 기호 엔진은 CFG를 횡단 하 여 프로그램 지점에 대 한 결합 상태를 이전 단계에서 계산할 수 있도록 해야 합니다.

도 10: 함수 foo의 상징적 실행: (a)가 없는 경우와 (b)가 있는 상태 병합.

예를 들어, 그래프가 비순환적인 경우, 위상학적 순서를 따른다. 그러나 이는 "흥미로운" 상태를 우선시하는 검색 탐색 전략을 방지할 것이다. (Kurz et al., 2018)는 탐색 전략에 의해 부과된 탐색 순서에 관계없이 작동하는 _동적 상태 병합_을 소개한다. 기호 엔진이 상태들의 워크리스트와 그들의 전임자들의 제한된 역사를 유지한다고 가정하자. 엔진이 탐색할 다음 상태를 선택해야 할 때, 먼저 작업목록에서 \(s_{1}\)과 \(s_{2}\)의 두 상태가 있는지 여부를 검사하여 병합을 위해 일치하지 않지만 \(s_{1}\)과 \(s_{2}\의 이전 상태가 있는지 검사한다. 만약 \(s_{2}\)과 \(s_{1}\)의 후속자 사이의 예상 유사도가 높은 경우, 알고리즘은 고정된 수의 단계에 대해 \(s_{1}\)의 실행을 앞당겨 병합을 시도한다. 이것은 두 상태가 유사하면 각각의 후계자도 몇 단계로 유사해질 가능성이 있다는 생각을 포착한다. 병합이 실패하면, 알고리즘은 탐색 휴리스틱이 탐색할 다음 상태를 선택할 수 있게 한다.

### 프로그램 분석 및 최적화 기법 활용

프로그램의 동작에 대한 더 깊은 이해는 기호 엔진이 분석을 최적화하고 예를 들어 계산 트리의 흥미롭지 않은 부분을 가지치기함으로써 유망한 상태에 초점을 맞추는 데 도움이 될 수 있다. 상징적 실행 문헌에서 몇 가지 고전적 프로그램 분석 기법이 탐색되었다. 우리는 이제 몇 가지 두드러진 예에 대해 간략하게 논의한다.

**프로그램 슬라이싱**: 프로그램의 동작의 하위 집합에서 시작 하는 이 분석은 해당 동작을 충실 하 게 나타내는 최소 명령 시퀀스를 프로그램에서 추출 합니다 (Kurz et al., 2018). 이 정보는 여러 가지 방법으로 심볼 엔진에 도움이 될 수 있다: 예를 들어, (Kurz et al., 2018)은 특정 타겟 프로그램 지점을 향해 심볼 탐사를 제한하기 위해 역방향 프로그램 슬라이싱을 이용한다.
**Taint Analysis.**: 이 기술(Kurz et al., 2018)은 프로그램의 어떤 변수가 사용자 입력과 같은 잠재적으로 위험한 외부 원본에서 파생된 값을 보유할 수 있는지 확인하려고 시도합니다. 분석은 정적으로 및 동적으로 수행될 수 있으며, 후자는 보다 정확한 결과를 산출한다. 기호적 실행의 맥락에서, 오염 분석은 엔진이 오염 값에 의존하는 경로를 탐지하는 데 도움이 될 수 있다. 예를 들어, (Kurz et al., 2018)는 점프 명령이 더럽혀지고 심볼릭 실행을 사용하여 익스플로잇을 생성하는 경로에 대한 분석을 집중한다.
**퍼징**: 이 소프트웨어 테스트 접근 방식은 사용자가 제공한 테스트 입력을 무작위로 변경하여 충돌 또는 주장 오류를 유발하여 잠재적인 메모리 누수를 찾을 수 있습니다. 퍼징은 입력에 대한 제약들을 수집하고 새로운 입력들을 생성하기 위해 그것들을 부정하기 위해 심볼릭 실행으로 증강될 수 있다. 한편, 심볼릭 실행기는 탐색에서 더 깊은 상태에 더 신속하고 효율적으로 도달하기 위해 퍼징으로 증강될 수 있다. 이 아이디어의 두 가지 주목할만한 실시예는 _하이브리드 콘콜릭 테스팅_(Kurz 등, 2018) 및 Driller(Kurz 등, 2018)로 표현된다.
**분기 예측**: 코드의 매우 작은 섹션에 대 한 점프를 방지 하 여 파이프라인 실행에서 잘못 예측 처벌을 완화 하기 위한 전략입니다. 예를 들어 C 삼진 연산자와 같은 제어 흐름 포킹 구성은 전용 선택 명령으로 대체 될 수 있습니다. (Kurz et al., 2018)은 심볼릭 실행을 사용하는 프로그램의 두 가지 구현을 교차 체크할 때 이 전략의 채택으로부터 탐색할 경로의 수의 기하급수적인 감소를 보고한다.
**유형 검사**: 기호 분석은 유형 검사와 효과적으로 혼합 될 수 있습니다 (Kurz 등, 2018): 예를 들어 유형 검사는 기호적으로 분석 하기 어려운 함수의 반환 유형을 결정할 수 있습니다. 그런 다음 이러한 정보는 실행기에서 특정 경로 1을 프루닝 하는 데 잠재적으로 사용할 수 있습니다.

각주 1: 이 작업은 또한 기호 분석이 예를 들어 특정 유형 오류를 배제하는 변수에 대한 상황에 민감한 특성을 제공하여 유형 검사기의 정밀도를 향상시킴으로써 유형 검사에 도움이 되는 방법에 대해 논의합니다.

**프로그램 디파이렌싱**: 종속성 분석은 코드 편집의 영향을 받는 분기 및 데이터 흐름을 식별할 수 있습니다. _ 지향적 증분 심볼릭 실행_(Kurz 등, 2018)은 변화에 의해 영향을 받는 CFG 노드를 정적으로 식별하고, 그러한 정보를 사용하여 영향을 받는 노드의 커버되지 않은 시퀀스를 실행하는 경로로만 탐색을 유도한다.

**컴파일러 최적화**: (Krishnan et al., 2018) 프로그램 최적화 기술은 검색 휴리스틱, 상태 병합 및 제약 조건 해결 최적화와 같이 널리 허용 되는 솔루션과 함께 기호 실행의 실제 구현의 첫 번째 클래스 구성 요소가 되어야 한다고 주장 합니다. 실제로 프로그램 변환은 경로 탐색 시 발생하는 제약 조건의 복잡성과 탐색 자체에 모두 영향을 미칠 수 있다. 예를 들어, 룩업 테이블을 사용하여 함수의 결과를 미리 계산하는 것은 메모리 액세스로 인해 경로 조건에서 더 많은 수의 제약으로 이어지는 반면, 곱셈에 대한 강도 감소를 적용하는 것은 제약 해결기에 대해 더 비싼 덧셈 연산의 연쇄를 초래할 수 있다. 또한 고급 스위치 문을 컴파일 하는 방법은 경로 탐색의 성능에 큰 영향을 줄 수 있는 반면 LLVM 또는 setcc 및 x86의 cmov와 같은 조건부 지침에 의존 하면 대신 간단한 _ite_ 식을 생성 하 여 고가 상태 포킹을 피할 수 있습니다.

컴파일러 최적화의 효과는 일반적으로 실행 시간에 실행되는 명령의 수 또는 크기에 대해 예측될 수 있지만, 유사한 감소는 심볼릭 실행에서 명백하지 않은데(Krishnan et al., 2018), 대부분 제약 해결기가 일반적으로 블랙-박스로 사용되기 때문이다. 우리가 아는 한 컴파일러 최적화가 제약 생성 및 경로 탐색에 미치는 영향을 분석하려고 시도한 연구는 소수에 불과하며(Krishnan et al., 2018; Krishnan et al., 2018), 흥미로운 열린 질문을 남겼다. 상이한 풍미가 (Krishnan et al., 2018)에 제시된 작업이며, 이는 어레이의 이론에 기초하여 심볼릭 실행기에서 메모리 동작을 고속화하기 위해 동적 상수 폴딩 및 최적화된 제약 인코딩과 같은 변환을 탐색한다(섹션 3.1).

## 6. 제약 사항 해결

제약 만족 문제는 소프트웨어 프로그램의 분석, 테스트 및 검증을 포함한 많은 영역에서 발생한다. 제약해법(constraint solvers)은 논리식으로 표현되는 문제에 대한 결정 절차이다. 예를 들어, 부울 만족성 문제(SAT라고도 함)는 그것을 참으로 만드는 공식의 기호에 대한 해석이 존재하는지 여부를 결정하는 것을 목표로 한다. SAT는 잘 알려진 NP-완전한 문제이지만, 최근의 발전은 실제 응용에 관한 한 다루기 어려운 것에 대한 경계를 이동시켰다(Krishnan et al., 2018).

일부 문제는 논리적 연결어가 있는 부울 공식 중 하나보다 더 표현력이 있는 언어로 더 자연스럽게 설명됩니다. 이러한 이유로, 만족성 모듈로 이론(SMT)은 SAT 문제를 선형 산술 및 연산과 같은 배열을 포함하는 공식을 포착하기 위해 지원하는 이론으로 일반화한다. SMT 해결자는 SMT 공식의 원자를 새로운 부울 변수에 매핑한다. SAT 결정 절차는 만족성을 위해 재작성된 공식을 확인하고 이론 해결자는 SAT 절차로 생성된 모델을 확인한다.

SMT 솔버는 몇 가지 독특한 장점을 보여준다. 그들의 핵심 알고리즘은 일반적이며 많은 개별 제약의 복잡한 조합을 처리할 수 있다. 제약 조건이 추가되거나 제거됨에 따라 점진적으로 작업하고 백트랙할 수 있으며 불일치에 대한 설명을 제공한다. 이론은 예를 들어 문자열의 배열에 대해 추론하기 위해 임의의 방식으로 추가 및 결합될 수 있다. 결정 절차는 별도로 수행될 필요가 없으며, 종종 비선형 산술 공식에서 선형 부분을 먼저 해결함으로써 더 무거운 절차에서 소비되는 시간을 줄이기 위해 이익스럽게 결합된다. 불완전한 절차도 가치가 있다: 완전하지만 결정적인 답을 낼 수 없을 때만 값비싼 절차가 호출된다. 이러한 모든 요인을 통해 SMT 해결사는 격리 2에서 단일 절차가 해결할 수 없는 큰 문제를 해결할 수 있다.

기호 실행기에서 제약 해결은 경로의 실현 가능성을 확인하고, 기호 변수에 대한 할당을 생성하며, 주장을 검증하는 데 중요한 역할을 한다. 수년에 걸쳐, 지지된 이론과 당시 상대적 성능에 따라 상징 실행기에 의해 다양한 해결사가 사용되었다. 예를 들어, STP [49] 해결기는 예를 들어 EXE [21], KLEE [20], 및 AEG [8]에 사용되었으며, 이는 모두 비트-벡터 및 어레이 이론에 대한 지원을 활용한다. Java PathFinder[77]와 같은 다른 실행기는 복잡한 비선형 수학적 제약을 처리하기 위해 추가적인 결정 절차(예를 들어, 제약 프로그래밍을 위한 라이브러리[83]) 및 휴리스틱으로 SMT 해결을 보완하였다[100].

최근 Z3[36]이 SMT 해결의 선도 솔루션으로 떠오르고 있다. 마이크로소프트 리서치에서 개발된 Z3는 최첨단 성능을 제공하며 비트 벡터, 배열, 양자화기, 해석되지 않은 함수, 선형 정수 및 실제 산술, 비선형 산술을 포함한 많은 이론을 지원한다. Z3-str[119]의 확장으로 문자열도 원시형으로 취급할 수 있어 연접, 부분 문자열, 교체 등의 일반적인 문자열 연산에 대해 풀이자가 추론할 수 있다. Z3는 Mayhem[25], SAGE[53], Angr[95]와 같은 가장 최근에 등장한 상징 실행기에 사용된다. Z3의 광범위한 지원 이론으로 인해 이러한 실행자는 일반적으로 추가 결정 절차를 사용하지 않는다.

그러나, 지난 몇 년 동안 관찰된 상당한 진보에도 불구하고 - 애초에 상징 실행도 실용화시켰음 - 제약 해결은 상징 실행 엔진의 확장성에 대한 주요 장애물 중 하나로 남아 있으며, 또한 값비싼 이론들(예를 들어, 비선형 산술) 또는 불투명한 라이브러리 호출들을 수반하는 제약들에 직면하여 그 실현 가능성을 방해한다.

이 섹션의 나머지 부분에서 상징적 실행에 적합한 프로그램의 범위를 확장하고 제약 조건 해결의 성능을 최적화하기 위해 다양한 기술을 다룬다. 유명한 접근 방법은 (i) 검사할 제약 조건의 크기와 복잡성을 줄이는 것, (ii) 제약 조건 솔루션 캐싱에 의존하거나, 해결사 쿼리의 지연 또는 구체화를 통해 해결사의 부담을 푸는 것, (iii) 결정 절차에 문제가 되는 제약 조건을 처리하기 위해 기호 실행을 늘리는 것이다.

#### Constraint Reduction

솔버와 기호 실행기가 뒤따르는 일반적인 최적화 접근법은 제약 조건을 더 간단한 형태로 줄이는 것이다. 예를 들어, _표현 재작성_ 최적화는 일정한 폴딩, 강도 감소, 및 선형 표현의 단순화와 같은 컴파일러를 최적화하는 것으로부터 고전적인 기술을 적용할 수 있다(예를 들어, KLEE [20] 참조).

EXE[21]는 제약사항들의 세트가 종종 제약사항들의 다수의 독립적인 서브세트들로 분할될 수 있다는 사실을 이용하는 _제약사항 독립성_ 최적화를 도입한다. 이 최적화는 질의 결과 캐싱 전략들과 잘 상호작용하며, 엔진이 질의에서 관계없는 제약 조건들을 제거하기 때문에 특정 제약 조건의 만족성에 대해 해결자에게 질문할 때 추가적인 이점을 제공한다. 실제로 실제 프로그램에서 빈번히 발생하는 경향이 있는 독립지점은 빠르게 누적될 불필요한 제약으로 이어질 수 있다.

축소 기법에 의해 악용될 수 있는 또 다른 사실은 프로그램의 자연적 구조가 실행이 진행됨에 따라 일부 변수에 대한 보다 구체적인 제약 조건의 도입으로 이어질 수 있다는 것이다. 경로 조건은 새로운 항을 기존 시퀀스에 결합함으로써 생성되기 때문에, 기존 제약 조건을 재작성하고 최적화하는 것이 가능해질 수 있다. 예를 들어, 형태 \(x:=5\)의 동일 제약 조건을 추가하면 변수의 값(예를 들어, \(x>0\))에 대한 다른 제약 조건의 참으로 단순화될 뿐만 아니라, 이를 포함하는 다른 후속 제약 조건에서의 연관된 구체적인 값으로 기호 \(x\)을 치환할 수 있다. 후자의 최적화는 또한 _implied value concretization_으로 알려져 있으며, 예를 들어 KLEE[20]에 의해 채용된다.

비슷한 정신으로, \(S^{2}\)E [29]는 비트 연산을 가리는 상징 변수의 구체적인 값 부분으로 대체하기 위해 비트 필드 이론 표현 단순화기를 도입한다. 예를 들어, 임의의 것에 대해
Symbolic Execution Techniques0:27에 대한 고찰

8비트 심볼 값 \(v\), 표현식의 값 \(v\,|\,10000000_{2}\)에서 가장 중요한 비트는 항상 1이다. 단순화기는 표현의 트리 표현에 정보를 전파할 수 있으며, 그 값의 각 비트를 결정할 수 있으면 해당 상수로 표현식을 대체한다.

제약조건 해법의 재사용 이전에 계산된 결과를 제약조건 해법의 속도를 높이기 위해 재사용하는 아이디어는 특히 제약조건 독립성 최적화와 같은 다른 기술과 결합될 때 기호 실행기의 설정에 특히 효과적일 수 있다. 제약 조건 해결을 위한 대부분의 재사용 접근법은 현재 제약 조건들의 의미적 또는 구문적 등가성에 기초하고 있다.

EXE[21]는 해결자를 호출할 필요성을 최대한 줄이기 위해 제약해와 만족성 질의의 결과를 캐싱한다. 캐시는 실행 엔진의 다수의 병렬 인스턴스로부터 질의를 수신할 수 있는 서버 프로세스에 의해 처리되며, 각각은 상이한 프로그램 상태를 탐색한다.

KLEE [20]은 _counterexample caching_ 이라는 증분 최적화 전략을 구현 합니다. 캐시를 사용 하 여 제약 조건 집합은 구체적인 변수 할당에 매핑 되거나 제약 조건 집합이 충족 되지 않을 때 특수 null 값에 매핑 됩니다. 캐시에서 만족스럽지 못한 집합이 주어진 제약 집합에 대한 부분 집합인 경우, \(S\), \(S\)도 만족스럽지 못한 것으로 간주된다. 반대로 캐시에 \(S\)의 슈퍼 세트에 대 한 솔루션이 포함 된 경우 솔루션도 \(S\)을 3 배로 충족 합니다. 마지막으로, 캐시가 \(S\)의 하나 이상의 부분집합에 대한 해를 포함할 때, 알고리즘은 \(S\)에 대한 만족스러운 해를 찾을 수 있는지 확인하기 위해 모든 해에 대입하려고 시도한다.

_메모화된 심볼릭 실행_[115]는 심볼릭 실행이 종종 버그를 찾고, 그것을 고친 다음, 그 고정이 효과적이었는지 확인하기 위해 프로그램을 다시 테스트하는 것과 같은 거의 유사한 서브-문제들을 재실행하는 것을 초래한다는 관찰에 의해 동기 부여된다. 경로 탐색 동안 취해진 선택은 접두사 트리에 컴팩트하게 인코딩되어 이전에 계산된 결과를 연속 실행에서 재사용할 가능성을 열어준다.

그린 프레임워크 [106]은 동일한 프로그램뿐만 아니라 유사한 프로그램, 다른 프로그램 및 다른 분석의 실행에서 제약 조건 솔루션 재사용을 탐구한다. 제약 조건은 _슬라이싱_ 변환을 통해 필수 부분으로 증류되고 단일 분석 실행 내에서도 좋은 재사용을 달성하기 위해 표준 형식으로 표시됩니다. [64] 제약 조건들 간의 논리적 함축 관계를 이용하여 제약 조건 재사용과 빠른 실행 시간을 지원하는 프레임워크로의 확장을 제시한다.

지연 제약 조건 [85]는 제약 조건 해결사 쿼리에 대해 시간 제한 방식을 채택 합니다. 초기 실험에서 저자는 대부분의 타임아웃을 기호 분할 및 나머지 연산으로 추적했으며, 최악의 경우는 서명되지 않은 나머지 연산이 분모에 기호 값을 가질 때 발생한다. 따라서 실행자가 값비싼 기호 연산을 포함 하는 분기 문을 만날 때 참 및 거짓 분기를 모두 사용 하 고 경로 조건에 값비싼 연산 결과에 대 한 _지연_ 제약 조건을 추가 하는 다음과 같이 작동 하는 솔루션을 구현 했습니다. 탐사가 목표(예를 들어, 오류가 발견됨)를 만족하는 상태에 도달하면 알고리즘은 경로의 실행 가능성을 확인하고 실제 실행에서 도달할 수 없는 것으로 간주되면 이를 억제한다.

접한 대로 분기의 실행 가능성을 확인하는 _eager_ 접근법(섹션 5.1)과 비교하여, 게으른 전략은 더 많은 수의 활성 상태로 이어질 수 있고, 차례로 더 많은 해결사 쿼리로 이어질 수 있다. 그러나, 지연 질의는 많은 경우 지연 제약 후에 추가되는 경로 제약은 실제로 해결자를 위한 솔루션 공간을 좁힐 수 있다고 저자는 보고한다.

Concetization[22]은 제약조건 풀이자들이 적어도 효율적으로 풀 수 없는 공식들이 존재할 때 고전적 기호 실행의 한계에 대해 논의한다. 콘콜릭 실행기는 프로그램에 대한 임의의 입력을 생성하고 이를 구체적이고 상징적으로 실행한다. 구체 실행에서 가능한 값은 탐사에서 건전성을 희생하는 대가를 치르더라도 본질적으로 해결자에게 어려운 공식에 관련된 상징적 피연산자에 사용될 수 있다.

**예제.** 그림 11의 코드 조각에서 엔진은 2행의 _true_ 분기에 대해 \(\alpha_{x}=(\alpha_{y}*\alpha_{y})\,\%\,50\) 형식의 비선형 제약 조건을 저장합니다. 비선형 산술을 지원하지 않는 해결사는 프로그램에 대한 입력을 생성하지 못합니다. 그러나, 콘콜릭 엔진은 해결자를 돕기 위해 구체적인 값을 이용할 수 있다. 예를 들어 \(x=3\) 및 \(y=5\)이 초기 입력 매개 변수로 무작위로 선택 된 경우 콘크리트 실행은 두 가지 분기 중 하나를 사용 하지 않습니다. 그러나 엔진은 \(\alpha_{y}=5\)으로 인해 이전 쿼리를 \(\alpha_{x}=25\)으로 단순화함으로써 \(y\)의 콘크리트 값을 재사용할 수 있다. 이 쿼리에 대한 간단한 솔루션은 이제 엔진에서 두 가지 분기를 모두 탐색하는 데 사용할 수 있습니다. 만약 \(y\)의 값이 \(5\)으로 고정된 경우, 첫 번째 분기를 차지하지만 두 번째 분기를 차지하지 않는 새로운 입력을 생성하여 거짓 음수를 유도하는 방법이 없다는 점에 주목하라. 이 경우 사소한 솔루션은 \(y\)에 대해 다른 값을 선택 하는 프로그램 (예: \(y=2\) 다음 \(x=4\)을 다시 실행 하는 것일 수 있으며, 이는 첫 번째 분기를 충족 하지만 두 번째 분기는 충족 하지 않습니다.

구체화로 인한 불완전성을 부분적으로 극복하기 위해, [78]은 하나 이상의 심볼을 특정 구체 값에 바인딩하기 전에 경로에 걸쳐 수집 가능한 경로 제약 조건을 _모두_ 고려하는 _혼합된 구체-상징적 해결_을 제안한다. 실제로, DART[51]는 타겟 브랜치까지 수집된 경로 제약들에 기초하여 심볼들을 구체화한다. 이러한 방식으로, 동일한 경로에서 후속 분기에 포함된 제약은 고려되지 않고 이미 구체화된 심볼들로 인해 만족스럽지 않을 수 있다. 이러한 경우, DART는 후속 분기를 만족시킬 수 있기를 희망하면서, 상이한 랜덤 콘크리트 값으로 실행을 재시작한다. [78]에 제시된 접근법은 대신 전체 경로를 따라 _해결 가능한_ 제약을 감지하고 가능한 한 구체화를 지연해야 한다.

**문제적 제약 조건 처리** 강력한 SMT 솔루션을 사용하면 실행자가 더 많은 경로 제약 조건을 직접 처리할 수 있으므로 구체화에 의존할 필요가 줄어듭니다. 이것은 또한 일부 변수에 대한 콘크리트 값의 무작위 선택에서 경로 조건의 과소 근사화가 탐색 공간의 임의적 제한을 초래할 때 발생하는 콘크리트 값에 대한 맹목적인 약속(39)을 유발할 위험이 더 낮다. 그러나, 제약들의 특정 클래스들에 대한 결정 문제는, 예를 들어, 비선형 정수 산술, 또는 현실 세계 시스템들을 모델링하기 위해 종종 사용되는 삼각 함수들을 갖는 리얼들의 이론에서와 같이, 결정 불가능한 것으로 잘 알려져 있다.

[39]는 비선형 산술 및 라이브러리 호출과 관련된 제어-흐름 의존성을 다룰 수 있는 _concolic walk_ 알고리즘을 제안한다. 이 알고리즘은 변수에 대한 값의 할당을 평가 공간으로 취급하는데, 선형 제약 조건의 솔루션은 휴리스틱하게 걸을 수 있는 폴리토프를 정의하고 나머지 제약 조건은 평가 지점이 제약 조건과 얼마나 가까운지를 측정하는 적합도 함수로 할당된다. 폴리토프에 대해 점들이 선택되고 비선형 제약 조건들이 평가됨에 따라 적응 탐색이 수행된다. 혼합 콘크리트-상징적 해결[78]에 비해 두 기법 모두 맹목적인 몰입을 피하고자 한다. 그러나 콘콜릭 보도는 복잡한 제약 조건을 평가하는 데 필요한 모든 구체적인 입력을 얻기 위해 솔루션에 의존하지 않으며 폴리톱에서 보도를 유망한 지역으로 안내하는 탐색 휴리스틱을 구현한다.

도 11: 비선형 제약조건을 갖는 실시예.

[40]은 심볼릭 백워드 실행(SBE)(섹션 2) 및 포워드 심볼릭 실행의 새로운 조합인 _심크레틱_ 실행을 설명한다. 주요 아이디어는 탐사를 두 단계로 나누는 것입니다. 첫 번째 단계에서는 목표 지점으로부터 SBE를 수행하고 추적된 경로마다 트레이스를 수집한다. 역방향 탐색 중에 문제가 되는 제약 조건이 충족 되는 경우 엔진은 추적에 특별한 이벤트를 추가 하 여 _잠재적으로_ 만족 가능한 것으로 표시 하 고 역방향 탐색을 계속 합니다. 프로그램의 엔트리 포인트가 뒤따르는 경로들 중 임의의 경로를 따라 도달할 때마다, 제2 단계가 시작된다. 엔진은 수집된 트레이스를 구체적으로 평가하여, 제1 단계 동안 문제가 있는 것으로 표시된 임의의 제약을 만족시키려고 한다. 이는 전술한 콘콜릭 워크와 같은 휴리스틱 검색을 사용하여 수행된다. 고전적인 콘콜릭 실행보다 심크레틱의 장점은 실현 불가능한 경로의 탐색을 방지할 수 있다는 것이다. 예를 들어, 후진 단계는 진술이 도달되는 방법에 관계없이 만족스럽지 못한 분기에 의해 보호되는 것으로 결정할 수 있는 반면, 전통적인 콘콜릭 실행기는 진술이 도달될 때만 경로당 기준으로 불가능을 검출할 것이며, 이는 경로에서 진술 "깊다"에 불리하다.

## 7. 추가 방향

이 섹션에서는 관련 연구 분야의 최근 발전이 상징 실행 기술의 최신 기술을 향상시키기 위해 어떻게 적용되거나 잠재적인 방향을 제공할 수 있는지 논의한다. 특히, 데이터 구조에 대한 분리 논리, 경로 폭발을 다루기 위한 프로그램 검증 및 프로그램 분석 영역으로부터의 기법, 비선형 제약 조건을 다루기 위한 기호 계산에 대해 논의한다.

### Separation Logic

포인터 프로그램에 대한 메모리 안전 특성을 확인하는 것은 프로그램 검증의 주요 과제이다. 최근 몇 년 동안 필수 프로그램에서 힙 조작에 대한 이성에 대한 하나의 선도적인 접근법으로 부상하는 분리 논리(SL)[86]가 목격되었다. SL은 포인터 데이터 구조를 조작하는 프로그램에 대한 추론을 용이하게 하기 위해 Hoare 로직을 확장하고, 간결한 방식으로 힙 구성의 복잡한 불변들을 표현할 수 있게 한다.

코어에서 _분리 연결자_ 이진 연산자 \(*\)를 사용 하 여 힙이 인수가 별도로 유지 되는 두 구성 요소로 분할 될 수 있다고 주장 합니다. 예를 들어, 술어 \(A*x\mapsto[n:y]\)는 \(n\) 필드에 \(y\)을 보유하는 레코드를 가리키는 단일 힙 셀 \(x\)이 있는 반면, \(A\)은 나머지 힙에 대해 유지된다고 말한다.

프로그램 상태는 _symbolic heap_\(\Pi\colon\Sigma\colon\Pi\)는 변수와 관련된 순수 술어의 유한 집합이고, \(\Sigma\)는 힙 술어의 유한 집합으로 모델링된다. 심볼릭 힙은 추상적 의미론을 사용하여 프로그램의 코드에 따라 상징적으로 실행되는 SL 공식이다. SL 규칙은 전형적으로 심볼릭 힙의 수반을 지원하고, 어떤 힙 부분이 문장의 영향을 받지 않는지를 추론하고, 추상화를 통한 심볼릭 실행의 종료를 보장하기 위해(예를 들어, 확장 연산자를 사용하여) 사용된다.

SL의 성공의 열쇠는 코드에 의해 액세스되는 유일한 메모리에 대해 말하는 사양을 허용하기 때문에 \(*\) 연산자에 의해 활성화되는 로컬 형태의 추론에 있다. 이는 또한 변이 가능한 데이터 구조를 설명하기 위해 귀납적 정의를 도출하는 목표와 일치한다. 다른 검증 접근법과 비교할 때, 사용자에 대한 주석 부담은 다소 적거나 종종 없다. 예를 들어, [23]에 제시된 형상 분석은 데이터 구조 상에서 불변들을 자동으로 발견하고 SL에서 합성 가능한 절차 요약을 계산하기 위해 바이-어빌딩을 사용한다.

SL을 기반으로 하는 여러 도구는 예를 들어 사용자 및 시스템 코드에서 자동 메모리 버그 발견, 메모리 안전 속성 또는 설계 패턴에 대한 주석이 달린 프로그램의 검증을 위해 현재까지 사용할 수 있다. 그들 중 일부는 맞춤형 결정 절차를 구현하지만 [15; 81]은 결정 가능한 SL 조각에 대한 프로버가 SMT 솔버에 통합되어 프로그램 검증과 관련된 다른 이론과의 완전한 조합을 허용할 수 있음을 보여주었다. 이는 보다 광범위한 환경에서 SL의 응용에 길을 열 수 있다. 예를 들어, 기호 실행기는 목록 및 트리와 같은 구조를 조작하는 코드에 대해 귀납적으로 추론하는 데 사용할 수 있다. 심볼 실행이 SL의 핵심이지만, 우리가 아는 한 지금까지 심볼 실행기에서 SL의 사용은 없었다.

### Invariants

불변은 프로그램의 완전한 기능 사양에 대해 올바른 프로그램을 증명할 수 있는 검증기에 매우 중요하다. 불변은 초기 상태와 그로부터 도달할 수 있는 각 상태에 대한 참이라는 술어이다. 불변량을 활용하는 것은 루프와 이성의 효과를 컴팩트하게 포착하기 위해 상징적 실행자에게 유익할 수 있다. 불행히도, 우리는 이 접근법을 이용하는 상징적인 집행자들에 대해 알지 못한다. 그 이유 중 하나는 도메인 전문가의 수동 개입을 필요로 하지 않고 루프 불변수를 계산하는 데 어려움이 있을 수 있다. 실제로 검증 실습에서 얻은 교훈은 루프 불변량을 제공하는 것이 방법 사전/사후 조건과 같은 다른 사양 요소에 비해 훨씬 더 어렵다는 것을 시사한다.

그러나, 최근 많은 연구자들이 루프 불변들을 자동으로 또는 거의 인간의 도움을 받지 않고 추론하는 기법들을 탐색하고 있다(Krishnan et al., 2018). 이는 루프의 보다 효율적인 처리를 위한 상징 실행 커뮤니티에 관심이 있을 수 있다. 이러한 접근법들은 일반적으로 상태 전이 관계 하에서 닫힌 귀납적 술어들을 대상으로 한다(즉, 그들은 과거의 동작을 참조하지 않는다). 모든 귀납적 술어는 불변이지만 그 역은 사실이 아니라는 것을 주목하라.

_종료 분석_은 산업 코드에 대한 프로그램 종료를 검증하기 위해 적용되었다: 형식적 인수는 전형적으로 모든 상태 전이에 대해, 적어도 하나의 함수가 감소하도록 프로그램 내의 모든 가능한 상태에 걸쳐 하나 이상의 랭킹 함수를 사용함으로써 구축된다(Krishnan et al., 2018). 랭킹 함수들은, 예를 들어, 횡단된 루프 경로들로부터의 반례들을 사용하여 불변수를 게으르게 구축함으로써, 다수의 방식들로 구성될 수 있다(Krishnan et al., 2018). 종료 인수는 또한 루프들이 전이 불변들에 기초한 요약들로 대체되는 변환된 프로그램들에 대한 추론에 의해 구축될 수 있다(Krishnan et al., 2018). 실제에서의 대부분의 루프들이 비교적 단순한 종결 인수를 갖는다는 것이 관찰되었다(Krishnan et al., 2018). 따라서, 발견된 불변들은 검증 설정을 위해 충분히 풍부하지 않을 수 있다(Krishnan et al., 2018). 그러나, 반복 횟수에 대한 상수 또는 파라메트릭 바운드는 랭킹 함수 및 불변으로부터 여전히 계산될 수 있다(Krishnan et al., 2018).

_Predicate 추상화_는 주어진 술어 세트를 사용하여 구성된 도메인에 대한 추상 해석의 한 형태이며, 어레이를 조작할 때 유용한 범용적으로 정량화된 루프 불변(Krishnan et al., 2018)을 추론하는 데 사용되었다. 술어들은 코드로부터 휴리스틱하게 수집되거나 사용자에 의해 공급될 수 있다: 심볼릭 실행과의 상호 보강 조합을 탐색하는 것은 흥미로울 것이며, 추가적인 유용한 술어들은 심볼릭 탐색 동안 유래된다.

_LoopFrog_(Krishnan et al., 2018)는 한 세트의 추상 도메인에 대해 심볼릭 추상 변환기를 사용하여 루프를 대체하여, 원래 코드의 보수적인 추상화를 획득한다. 추상 변압기는 가장 안쪽 루프에서 시작하여 계산되며 출력은 검증을 위해 모델 체커에 전달할 수 있는 프로그램의 루프 없는 요약이다. 이 접근법은 비재귀 함수 호출에도 적용될 수 있으며 상징 실행기에서 약간의 조사를 받을 자격이 있다.

루프 불변들은 또한 상이한 목표들에 대해 심볼릭 실행에서 이미 적용된 일반적인 기법인 _인터폴레이션_ 을 사용하여 추출될 수 있다(섹션 5.3).

### Function Summaries

함수 요약(섹션 5.2)은 주로 정적 및 동적 프로그램 분석, 특히 프로그램 검증에 사용되었다. 그러한 많은 작품들은 상징적 실행에서 예술의 상태를 발전시킬 수 있는 흥미로운 기회를 제공할 수 있다. 예를 들어, Calysto static checker(Cabrera et al., 2018)는 프로그램의 호출 그래프를 걸어 각 함수의 효과, 즉 반환 값, 글로벌 변수에 대한 쓰기, 및 그 인수에 따라 액세스되는 메모리 위치의 기호 표현을 구성한다. 각 기능은 한 번 처리되므로 호출 사이트에서 작은 기능의 효과를 표시할 수 있습니다. 요약 구성에서 건전성을 위한 Calysto 및 Saturn(114) 무역 확장성과 같은 정적 체커는 루프를 소수의 반복으로만 풀기 때문에, 기호 실행 설정에서의 사용은 따라서 건전성의 손실을 초래할 수 있다. 함수의 효과들을 메모하기 위한 요약 캐시를 사용하여 상이한 입력 조건들을 고려함으로써 더 세밀한 요약들이 (44)에서 구성된다.

(93)은 다수의 사양이 전형적으로 한 번에 하나씩 체크되는 모델 체크를 위한 함수 요약을 추출하는 기술을 제안하여, 요약을 검증 실행에 걸쳐 재사용할 수 있다. 특히, 이들은 보간법(섹션 5.3)을 사용하여 과근사로 계산되고 너무 약할 때 런에 걸쳐 정제된다. 이 기법의 강점은 보간제 기반 요약이 함수 자체보다 더 컴팩트한 방식으로 함수를 통해 가능한 모든 실행 트레이스를 캡처할 수 있다는 사실에 있다. 이 기술은 나중에 (92)에서 내포 함수 호출들을 다루기 위해 확장되었다.

### 프로그램 분석 및 최적화

우리는 기호 실행 연습이 프로그래밍 언어 영역의 관련 문제에 대해 제안된 솔루션으로부터 더 많은 이점을 얻을 수 있다고 믿는다. 예를 들어, 병렬 컴퓨팅 커뮤니티 변환에서 _루프 합체_(11)과 같은 변환은 중첩된 루프를 인덱스의 반복 공간을 평탄화함으로써 단일 루프로 재구성할 수 있다. 이러한 변환은 잠재적으로 상징적 탐색을 단순화하고 탐색 휴리스틱 및 상태 병합 전략을 강화할 수 있다.

루프 언폴딩_(99)은 여러 반복을 벗겨내어 "웰-구조화된" 루프(예를 들어, 불변 코드를 보여주거나, 또는 상수 또는 어파인 함수를 어레이 참조의 첨자로 갖는)를 노출시키는 것을 허용하기 때문에 아마도 흥미로울 수 있다.

_Program synthesis_는 상위 레벨 사양을 만족하는 프로그램을 자동으로 구성한다(82). 이 기법은 (97)이 SAT 문제에 대한 해결책으로 프로그램을 찾는 방법을 보여주었기 때문에 검증 커뮤니티의 관심을 끌었다. 섹션 4에서는 복잡한 Java 프레임워크에 대한 컴팩트한 모델을 생성하기 위한 (63)의 사용에 대해 논의했는데, 이 기술은 프레임워크에서 입력 클래스, 방법 및 유형을 취하고 튜토리얼 프로그램(일반적으로 공급업체에서 제공하는 프로그램)과 함께 부품을 행사한다. 우리는 이 접근법이 경로 폭발 문제의 맥락에서 더 조사할 가치가 있다고 믿는다. 합성은 구현의 얽힘을 추상화하면서 외부 동작을 캡처할 수 있기 때문에 검색 공간을 보다 확장 가능한 탐색을 허용하는 간결한 모델을 생성하기 위해 표준 라이브러리와 같은 소프트웨어 모듈에 잠재적으로 적용될 수 있다.

### Symbolic Computation

수능에 대한 만족성 문제는 이미 NP-hard로 알려져 있지만, 지난 수십 년 동안의 수학적 발전은 산술 공식을 풀기 위한 몇 가지 실용적인 방법을 만들어냈다. 특히, _상징연산_의 발전은 다항식 제약조건을 풀기 위한 Grobner 기반, 실수 대수 기하학을 위한 원통형 대수 분해, 다항식의 정도가 4(1) 이하인 다항식 실수 산술식을 위한 가상 치환과 같은 강력한 방법을 생산했다.

SMT 해결기는 복잡한 표현을 처리할 때 이론과 휴리스틱을 결합하는 데 매우 효율적이지만, 기호 계산 기법을 약간만 사용하고 비선형 실수 및 정수 연산에 대한 지원은 아직 초기 단계(1)이다. 우리가 아는 한 Z3(36)와 SMT-RAT(33)만이 둘 다에 대해 추론할 수 있다.

(1) SMT 솔버에 대한 이론 플러그인으로 기호 계산 기법을 사용하는 것은 산술 제약의 연결을 해결하기 위한 강력한 절차를 제공하기 때문에 유망한 공생이라고 명시한다. 이 아이디어의 실현은 그러한 절차의 사용 가능한 구현이 SMT 준수 이론 해결사에서 예상되는 불일치 속성에 대한 점진적, 역추적 및 설명을 준수하지 않는다는 사실에 의해 방해받는다. 한 가지 흥미로운 프로젝트는 SC\({}^{2}\)(Baldoni et al., 2018)인데, 이 프로젝트는 상징적 계산과 만족성 검사 사이의 격차를 해소하는 새로운 커뮤니티를 만드는 것을 목표로 하며, 두 세계의 장점을 결합하여 현재 개인의 범위를 넘어서는 문제를 추구한다.

비선형 표현을 다룰 때 효율성을 높일 수 있는 추가 기회는 _상징-숫자 계산_의 최근 발전에서 찾을 수 있다. 특히, 이러한 기법들은 국부해를 근사화하는데는 매우 효율적이지만 전역적 관점이 부족한 수치적 알고리즘들을 심볼릭 연산 기법으로부터 보장하는 결합으로 효율적인 다항식 해법들을 개발하는 것을 목표로 한다. 이 하이브리드 기법은 효율적으로 풀 수 있는 문제들의 영역을 확장할 수 있으며, 따라서 심볼릭 실행으로부터 비선형 제약 조건들에 대한 관심이 있다.

## 8. Conclusions

심볼릭 실행 기술은 지난 10년 동안 크게 발전하여 소프트웨어 테스트(예: 테스트 입력 생성, 회귀 테스트), 보안(예: 악용 생성, 인증 우회), 코드 분석(예: 프로그램 역난독화, 동적 소프트웨어 업데이트)과 같은 여러 도메인의 강력한 문제에 주목할 만한 응용 프로그램이 있다. 이러한 추세는 기존 솔루션을 개선할 뿐만 아니라 새로운 아이디어와 경우에 따라 주요 실질적인 돌파구로 이어졌다. 예를 들어, 보안에서 확장 가능한 자동화된 프로그램 분석을 위한 추진은 거의 4M 상금을 놓고 경쟁한 Angr(Kolmogorov, 2018) 및 Mayhem(Kolmogorov, 2018)과 같은 인간의 개입 없이 알려지지 않은 소프트웨어의 취약점을 감지하고 수정하기 위한 시스템을 호스팅한 2016 DARPA 사이버 그랜드 챌린지에서 절정에 달했다.

이 조사는 상징 실행의 주요 측면과 과제에 대해 논의했으며, 광범위한 청중에게 상징 실행기의 기본 설계 원칙과 주요 최적화 기술을 제시했다. 우리는 비전문가들이 이 흥미로운 연구 라인에서 핵심 발명품을 파악하여 추가 작업과 새로운 아이디어를 고무하는 데 도움이 되기를 바랍니다.

## Electronic Appendix

이 원고의 온라인 부록은 상징 실행 기술의 두드러진 응용 프로그램의 선택에 대해 논의하고, 이진 형식의 프로그램 분석에서 발생하는 추가 문제를 해결하고 인기 있는 상징 엔진 목록을 제공한다.

## Acknowledgments

우리는 그들의 귀중한 논평과 도움이 되는 제안에 대해 익명의 심판들에게 감사한다. 이 작업은 부분적으로 이탈리아 각료 협의회의 회장직 부여와 CINI(Consorzio Interuniversitario Nazionale Informatica) 국가 사이버 보안 연구소에 의해 지원된다.

## References

* Abraham (2015) Erika Abraham. 2015. Building Bridge Between Symbolic Computation and Satisfiability Check. _Proc. 2015 ACM on Int. Symp. on Symbolic and Algebraic Computation (ISSAC'15)_. ACM, 1-6. [https://doi.org/10.1145/2755996.2756636](https://doi.org/10.1145/2755996.2756636)
* Abraham et al. (2016) Erika Abraham, John Abbott, Bernd Becker, Anna M. Bigatti, Martin Brain, Bruno Buchberger, Alessandro Cimatti, James H. Davenport, Matthew England, Pascal Fontaine, Stephen Forrest, Alberto Griggio, Daniel Kroening, Werner M. 실러와 토마스 스터름 2016. SC2: Satisfiability Checking Meets Symbolic Computation. _Proc. 9th Int. Conf. 지능형 컴퓨터 수학에서. (CIKM'16)_. Springer, 28-43. [https://doi.org/10.1007/978-3-319-42547-4_3](https://doi.org/10.1007/978-3-319-42547-4_3)
* Anand (2012) Saswat Anand. 2012. _실세계 프로그램의 상징적 실행을 촉진하는 기술_. 박사 학위요 미국 조지아주 애틀랜타 해럴드, 메리 진 AAI3531671
* Anand et al. (2008) Saswat Anand, Patrice Godefroid, and Nikolai Tillmann. 2008. Demand-driven Compositional Symbolic Execution. _Proc. 소프트웨어의 이론 및 실행, 14번째 인트. Conf. TACAS'08/ETAPS'08)_의 시스템 구축 및 분석을 위한 도구 및 알고리즘 367-381.

* Anand et al. (2007) Saswat Anand, Alessandro Orso, and Mary Jean Harrold. 2007. Type-dependence Analysis and Program Transformation for Symbolic Execution. _Proc. 13th Int. Conf. 시스템 구축 및 분석을 위한 도구 및 알고리즘(TACAS'07)_. 117-133.
* Anand et al. (2009) Saswat Anand, Corina S. 파사레아누와 빌렘 비저 2009. Symbolic Execution with Abstraction. _ Int. J. Software Tools Technol. Transf._ 11, 1(2009), 53-67).
* Avgerinos (2014) Thanassis Avgerinos. 2014. _보안 Bugs 식별을 위한 Symbolic Execution에서 트레이드오프를 이용_ 합니다. 박사 학위요 Advisor(s) Brumley, David. [http://repository.cmu.edu/cgi/viewcontent.cgi?article=1478&context=dissertations] (http://repository.cmu.edu/cgi/viewcontent.cgi?article=1478&context=dissertations).
* Avgerinos 등(2011) Thanassis Avgerinos, Sang Kil Cha, Brent Lim Tze Hao, and David Brumley. 2011. AEG: 자동 익스플로잇 생성. _Proc. 네트워크 및 분산 시스템 보안 심프. (NDSS'11)_.
* Avgerinos 등(2014) Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014. Enhancing Symbolic Execution with Verieties. _Proc. 36th Int. Conf. on Software Engineering (ICSE'14)_. ACM, 1083-1094. [https://doi.org/10.1145/2568225.2568293](https://doi.org/10.1145/2568225.2568293)
* Babic and Hu (2008) Domagoj Babic and Alan J. Hu. 2008. Calysto: Scalable and Precise Extended Static Check. _Proc. 30th Int. Conf. on Software Engineering (ICSE'08)_. ACM, 211-220. [https://doi.org/10.1145/1368088.1368118](https://doi.org/10.1145/1368088.1368118)
* Bacon 등(1994) David F. Bacon, Susan L. 그레이엄, 올리버 제이 샤프 1994. Compiler Transformations for High-performance Computing. _ ACM Computing Surveys (CSUR)_ 26, 4 (1994), 345-420. [https://doi.org/10.1145/197405.197406](https://doi.org/10.1145/197405.197406)
* Ball et al.(2006) Thomas Ball, Ella Boumumov, Byron Cook, Vladimir Levin, Jakob Lichtenberg, Con McAravey, Bohus Ondrusek, Sriram K. 라자마니와 압둘라 우스투넨 2006. Dropouting Static Analysis of Device Drivers. _Proc. 제1차 ACM SIGOPS/EuroSys European Conf. on Comp. Systems (EuroSys'06)_. ACM, 73-85. [https://doi.org/10.1145/1217935.1217943](https://doi.org/10.1145/1217935.1217943)
* Barrett 등(2014) Clark Barrett, Daniel Kroening, and Thomas Melham. 2014. _21세기의 문제 해결: 만족성 모듈로 이론을 위한 효율적인 해결기_. 런던 수리 학회와 스미스 연구소
* Boonstopel 등(2008) Peter Boonstopel, Cristian Cadar, and Dawson R. 잉글러 2008. RWset: Attacking Path Explosion in Constraint-Based Test Generation. _Proc. 14th Int. Conf. 시스템 구축 및 분석을 위한 도구 및 알고리즘(TACAS'08)_ 351-366. [https://doi.org/10.1007/978-3-540-78800-3_27](https://doi.org/10.1007/978-3-540-78800-3_27)
* Botinan et al.(2009) Matko Botinan, Matthew Parkinson, and Wolfram Schulte. 2009. Separation Logic Verification of C Programs with a SMT Solver. _ Electronic Notes in Theoretical Comp. Science_ 254 (2009), 5-23. [https://doi.org/10.1016/j.entcs.2009.09.057](https://doi.org/10.1016/j.entcs.2009.09.057)
* 상징적 실행에 의한 프로그램 테스트 및 디버깅을 위한 형식 시스템입니다. _Proc. (p<0.05). Conf. 신뢰할 수 있는 소프트웨어_에 있습니다. ACM, 234-245. [https://doi.org/10.1145/800027.808445](https://doi.org/10.1145/800027.808445)
* Brumley 등(2011) David Brumley, Ivan Jager, Thanassis Avgerinos, and Edward J. Schwartz. 2011. BAP: A Binary Analysis Platform. _Proc. 23rd Int. Conf. 컴퓨터 지원 검증(CAV'11)_. 463-469. [https://doi.org/10.1007/978-3-642-22110-1_37](https://doi.org/10.1007/978-3-642-22110-1_37)
* Bucur 등(2011) Stefan Bucur, Vlad Ureche, Cristian Zamfir, and George Candea. 2011. Parallel Symbolic Execution for Automated Real-world Software Testing. _Proc. 6번째 Conf. on Comp. Systems (EuroSys'11)_. 183-198. [https://doi.org/10.1145/1966445.1966463](https://doi.org/10.1145/1966445.1966463)
* Cadar(15) Cristian Cadar. 15. Symbolic Execution을 위한 타겟 프로그램 변환. _Proc. 2015년 10차 소프트웨어 공학 기초 공동 회의(ESEC/FSE'15)_. ACM, 906-909. [https://doi.org/10.1145/2786805.2803205](https://doi.org/10.1145/2786805.2803205)
* Cadar 등(2008) Cristian Cadar, Daniel Dunbar, and Dawson R. 잉글러 2008. KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs. _Proc. 8th USENIX Conf. OSDI'08_ 운영체제 설계 및 구현 USENIX 협회, 209-224
* Cadar 등(2006) Cristian Cadar, Vijay Ganesh, Peter M. 데이비드 팔로우스키 딜과 도슨 R. 잉글러 2006. EXE: 자동으로 죽음의 입력들을 생성한다. _Proc. 13번째 ACM Conf. on Computer and Communications Security (CCS'06)_. ACM, 322-335. [https://doi.org/10.1145/1180405.1180445](https://doi.org/10.1145/1180405.1180445)
* Cadar and Sen (2013) Cristian Cadar and Koushik Sen. 2013. Symbolic Execution for Software Testing: 3 Decade Later. _ Commun. ACM_ 56, 2 (2013), 82-90. [https://doi.org/10.1145/2408776.2408795](https://doi.org/10.1145/2408776.2408795)
* Calcagno et al. (2011) Cristiano Calcagno, Dino Distefano, Peter W. 오헌, 양홍석. 2011. Bi-Abduction 수단에 의한 조성 형상 분석. _ 제이 ACM_ 58, 6, Article 26 (2011). [https://doi.org/10.1145/2049697.2049700] (https://doi.org/10.1145/2049697.2049700)
* Ceccardi and Tachakula (2014) Matteo Ceccardi and Oksana Tachakula. 2014. Automated Generation of Model Classes for Java PathFinder. _ SIGSOFT Software Engineering Notes_ 39, 1 (2014), 1-5. [https://doi.org/10.1145/2557833.256572](https://doi.org/10.1145/2557833.256572)
* Cha 등(2012) Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012. Unleashing Mayhem on Binary Code. _Proc. 2012 IEEE Symp. on Sec. 및 프라이버시(SP'12)_를 포함한다. IEEE Comp. Society, 380-394. [https://doi.org/10.1109/SP.2012.31](https://doi.org/10.1109/SP.2012.31)
* Chandra 등(2009) Satish Chandra, Stephen J. Fink, and Manu Sridharan. 2009. Snuuglebug: A powerful approach to Weakest Preconditions. _Proc. 30번째 ACM SIGPLAN Conf. on Prog. 랭 설계 및 삽입입니다. (PLDI'09)_. ACM, 363-374. [https://doi.org/10.1145/1542476.1542517](https://doi.org/10.1145/1542476.1542517)
* Chen 등(2015) Ting Chen, Xiaodong Lin, Jin Huang, Abel Bacchus, and Xiaosong Zhang. 2015. Empirical Investigation to Path Divergence for Concolic Execution using CREST. _ Security and Communication Networks_ 8, 18 (2015), 3667-3681. [https://doi.org/10.1002/sec.1290](https://doi.org/10.1002/sec.1290)* Chen et al. (2013) Ting Chen, Xiao-Song Zhang, Shi-Ze Guo, Hong-Yuan Li, and Yue Wu. 2013. State of the Art: Dynamic Symbolic Execution for Automated Test Generation. _ 미래의 장군 컴퓨팅. Syst._ 29, 7 (2013), 1758-1773. [https://doi.org/10.1016/j.future.2012.02.006](https://doi.org/10.1016/j.future.2012.02.006)
* Chipounov 등(2012) Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2012. The S2E Platform: Design, Implementation, and Applications. _ ACM Trans. on Computer Systems (TODS)_ 30, 1 (2012), 2:1-2:49. [https://doi.org/10.1145/2110356.2110358](https://doi.org/10.1145/2110356.2110358)
* Collingbourne 등(2011) Peter Collingbourne, Cristian Cadar, and Paul H.J. Kelly. 2011. Symbolic Crosschecking of Floating-point and SIMD Code. _Proc. 제6 Conf. on Computer Systems (Euro5ys'11)_. ACM, 315-328. [https://doi.org/10.1145/1966445.1966475](https://doi.org/10.1145/1966445.1966475)
* Cook et al.(2006) Byron Cook, Andreas Podelski, and Andrey Rybalchenko. 2006. Termination Proofs for Systems Code. _Proc. 27번째 ACM SIGPLAN Conf. on Prog. 랭 설계 및 Impl._ 415-426. [https://doi.org/10.1145/1133981.1134029](https://doi.org/10.1145/1133981.1134029)
* Coppa 등(2017) Emilio Coppa, Daniele Cono D'Elia, and Camil Demetrescu. 2017년 상징적 실행에서 포인터 추론에 대한 재고 _Proc. 32nd IEEE/ACM Int. Conf. on Automated Software Engineering (ASE'17)_. 613-618.
* Corzilius et al.(2015) Florian Corzilius, Geroon Kremer, Sebastian Junges, Stefan Schupp, and Erika Abraham. 2015. SMT-RAT: Strategic and Parallel SMT Solving을 위한 Open Source C++ Toolbox. _Proc. 18th Int. Conf. on Theory and Applications of Satisfiability Testing (SAT'15)_, Marijn Heule and Sean Weaver (Eds.). 360-368. [https://doi.org/10.1007/978-3-319-24318-4_26](https://doi.org/10.1007/978-3-319-24318-4_26)
* Craig (1957) William Craig. 1957. Herbrand-Gentzen 정리의 관계모델론과 증명이론에서의 세 가지 활용 제이 Symbolic Logic_22, 3(1957), 269-285.
* Csallner and Smaragdakis (2005) Christoph Csallner and Yannis Smaragdakis. 2005. Check 'N' Crash: Combining Static Check and Testing. _Proc. 27th Int. Conf. on Software Engineering (ICSE'05)_. ACM, 422-431. [https://doi.org/10.1145/1062455.1062533](https://doi.org/10.1145/1062455.1062533)
* De Moura and Bjorner (2008) Leonardo De Moura and Nikolaj Bjorner. 2008. Z3: An Efficient SMT Solver. _Proc. 소프트웨어의 이론 및 실행, 14번째 인트. Conf. TACAS'08/ETAPS'08)_의 시스템 구축 및 분석을 위한 도구 및 알고리즘 337-340. [https://doi.org/10.1007/978-3-540-78800-3_2](https://doi.org/10.1007/978-3-540-78800-3_2)
* Do Moura and Bjorner (2011) Leonardo De Moura and Nikolaj Bjorner. 2011. Satisfiability Modulo Theory: 소개 및 응용. _ Commun. ACM_ 54, 9 (2011), 69-77. [https://doi.org/10.1145/1995376.1995394](https://doi.org/10.1145/1995376.1995394)
* Deng 등(2012) Xianghua Deng, Joyong Lee, and Robby. 2012. Efficient and formal generalized Symbolic Execution. _ Automated Software Engineering_ 19, 3 (2012), 233-301. [https://doi.org/10.1007/s10515-011-0089-9](https://doi.org/10.1007/s10515-011-0089-9)
* Dinges and Agha (2014) Peter Dinges and Gul Agha. 2014. Solving Complex Path Conditions through Heuristic Search on Induced Polytopes. _Proc. 22nd ACM SIGSOFT Int. Symp. 소프트웨어공학의 기초에 관하여. 425-436. [https://doi.org/10.1145/263586.2635889](https://doi.org/10.1145/263586.2635889)
* Dinges and Agha (2014) Peter Dinges and Gul Agha. 2014. Targeted Test Input Generation Using Symbolic-concrete Backward Execution. _Proc. 29th ACM/IEEE Int. Conf. on Automated Software Engineering (ASE'14)_. 31-36. [https://doi.org/10.1145/2642937.2642951](https://doi.org/10.1145/2642937.2642951)
* Dong et al.(2015) Shiyu Dong, Oswaldo Olivo, Lingming Zhang, and Sarfraz Khurshid. 2015. 표준 컴파일러 최적화가 상징적 실행에 미치는 영향 연구 _Proc. 2015 IEEE 26th Int. Symp. on Software Reliability Engineering_. 205-215. [https://doi.org/10.1109/ISSRE.2015.7381814](https://doi.org/10.1109/ISSRE.2015.7381814)
* Duestrewald (Ed.) Evenly Duestrewald (Ed.). 2004. _Analysisyzing Memory Accesses in x86 Executables_ Springer. [https://doi.org/10.1007/978-3-540-24723-4_2] (https://doi.org/10.1007/978-3-540-24723-4_2)
* Elkarabileh et al. (2009) Bassem Elkarabileh, Patrice Godefroid, and Michael Y. 레빈 2009. Precise Pointer Reasoning for Dynamic Test Generation. _Proc. 18th Int. Symp. on Software Testing and Analysis (ISSTA'09)_. ACM, 129-140. [https://doi.org/10.1145/1572272.1572288](https://doi.org/10.1145/1572272.1572288)
* Engler and Ashcraft (2003) Dawson R. 잉글러와 켄 애쉬크래프트 2003. RacerX: Effective, Static Detection of Race Conditions and Deadocks. _Proc. 19번째 ACM Symp. on Operating Systems Principles (SOSP'03)_. ACM, 237-252. [https://doi.org/10.1145/945445.945468](https://doi.org/10.1145/945445.945468)
* Engler and Dunbar (2007) Dawson R. 잉글러와 대니얼 던바 2007. Under-constrained Execution: Automatic Code Destruction easy and Scalable. _Proc. of 2007 Int. Symp. 소프트에서 테스트 및 분석(ISSTA'07)_. 1-4. [https://doi.org/10.1145/1273463.1273464](https://doi.org/10.1145/1273463.1273464)
* Flanagan and Qadeer (2002) Cormac Flanagan and Shaz Qadeer. 2002. Predicate Abstraction for Software Verification. _Proc. 29번째 ACM SIGPLAN-SIGACT Symp. 농사의 원칙에 따라. 랭 (POPL'02)_. ACM, 191-202. [https://doi.org/10.1145/503272.503291](https://doi.org/10.1145/503272.503291)
* Aruria et al. (2014) Carlo A. Aruria, Bertrand Meyer, and Sergey Velder. 2014. Loop Invariants: Analysis, Classification, and Example. _ ACM Computing Surveys (CSUR)_ 46, 3, Article 34 (2014). [https://doi.org/10.1145/2506375] (https://doi.org/10.1145/2506375)
* Galeotti 등(2015) Juan P. Galeotti, Carlo A. Furia, Eva May, Gordon Fraser, and Andreas Zeller. 2015. Inferring Loop Invariants by Mutation, Dynamic Analysis, and Static Check. _ IEEE Trans. on Software Engineering (TSE)_ 41, 10 (2015), 1019-1037. [https://doi.org/10.1109/TSE.2015.2431688](https://doi.org/10.1109/TSE.2015.2431688)
* Ganesh and Dill (2007) Vijay Ganesh and David L. 딜 2007. A Decision Procedure for Bit-vector and Arrays. _Proc. 19th Int. Conf. 컴퓨터 지원 검증(CAV'07)_. 519-531. [https://doi.org/10.1007/978-3-540-73368-3_52](https://doi.org/10.1007/978-3-540-73368-3_52)
* Godefroid (2007) Patrice Godefroid. 2007. Compositional Dynamic Test Generation. _Proc. 34번째 ACM SIGPLAN-SIGACT Symp. 농사의 원칙에 따라. 랭 (POPL'07)_. 47-54. [https://doi.org/10.1145/1190216.1190226](https://doi.org/10.1145/1190216.1190226)
* Godefroid 등(2005) Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Automated Random Testing. _Proc. ACM SIGPLAN Conf. on Prog. 랭 설계 및 삽입입니다. (PLDI'05)_. 213-223. [https://doi.org/10.1145/1065010.1065036](https://doi.org/10.1145/1065010.1065036)* [52] Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated Whitebox Fuzz Testing. In _Proc. Network and Distributed System Security Symp. (NDSS'08)_
* [53] Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2012. SAGE: Whitebox Fuzzing for Security Testing. _Queue_ 10, 1, Article 20 (2012), 20:20-20:27 pages. [https://doi.org/10.1145/2090147.2094081](https://doi.org/10.1145/2090147.2094081)
* [54] Patrice Godefroid and Daniel Luchaub. 2011. Automatic Partial Loop Summarization in Dynamic Test Generation. In _Proc. 2011 Int. Symp. on Software Testing and Analysis (ISSTA'11)_. ACM, 23-33. [https://doi.org/10.1145/2001420.2001424](https://doi.org/10.1145/2001420.2001424)
* [55] Laureo Gomond, David Monniaux, and Gabriel Radame. 2015. Synthesis of Ranking Functions Using Extremal Counterexamples. In _Proc. 36th ACM SIGPLAN Conf. on Prog. Lang. Design and Impl. (PLDI'15)_. ACM, 608-618. [https://doi.org/10.1145/2737924.2737976](https://doi.org/10.1145/2737924.2737976)
* [56] Johannes Grabmeier, Erich Kaltofen, and Volker Weispfenning. 2003. _Computer Algebra Handbook: Foundations, Applications, Systems_. Vol. 1. Springer Science & Business Media, 109-124.
* [57] Trevor Hansen, Peter Schachte, and Harald Sondergaard. 2009. Runtime Verification. Chapter State Joining and Splitting for the Symbolic Execution of Binaries, 76-92. [https://doi.org/10.1007/978-3-642-04694-0_6](https://doi.org/10.1007/978-3-642-04694-0_6)
* [58] William E. Howden. 1977. Symbolic Testing and the DISSECT Symbolic Evaluation System. _IEEE Trans. on Software Engineering (TSE)_ 3, 4 (1977), 266-278. [https://doi.org/10.1109/TSE.1977.231144](https://doi.org/10.1109/TSE.1977.231144)
* [59] Joxan Jaffar, Vijayaraghavan Murali, and Jorge A. Navas. 2013. Boosting Concolic Testing via Interpolation. In _Proc. 2013 9th Joint Meeting on Foundations of Software Engineering (ESEC/FSE'13)_. ACM, 48-58. [https://doi.org/10.1145/2494114.2494125](https://doi.org/10.1145/2494114.2494125)
* [60] Joxan Jaffar, Vijayaraghavan Murali, Jorge A. Navas, and Andrew E. Santosa. 2012. TRACER: A Symbolic Execution Tool for Verification. In _Proc. 24th Int. Conf. on Comp. Aided Verification (CAV'12)_. 758-766. [https://doi.org/10.1007/978-3-642-31424-7_61](https://doi.org/10.1007/978-3-642-31424-7_61)
* [61] Joxan Jaffar, Jorge A. Navas, and Andrew E. Santosa. 2012. Unbounded Symbolic Execution for Program Verification. In _Proc. 2nd Int. Conf. on Runtime Verification (RV'11)_. 396-411. [https://doi.org/10.1007/978-3-642-29860-8_32](https://doi.org/10.1007/978-3-642-29860-8_32)
* [62] Joxan Jaffar, Andrew E. Santosa, and Riazvan Voicu. 2009. An Interpolation Method for CLP Traversal. In _Proc. 15th Int. Conf. on Principles and Practice of Constraint Programming (CP'09)_. 454-469.
* [63] Jinesong Jeon, Xiaokang Qiu, Jonathan Fetter-Degges, Jeffrey S. Foster, and Armando Solar-Lezama. 2016. Synthesizing Framework Models for Symbolic Execution. In _Proc. 38th Int. Conf. on Software Engineering (ICSE'16)_. ACM, 156-167. [https://doi.org/10.1145/2884781.2884856](https://doi.org/10.1145/2884781.2884856)
* [64] Xiangyang Jia, Carlo Ghezzi, and Shi Ying. 2015. Enhancing Reuse of Constraint Solutions to Improve Symbolic Execution. In _Proc. 2015 Int. Symp. on Software Testing and Analysis (ISSTA'15)_. 177-187. [https://doi.org/10.1145/2771783.2771806](https://doi.org/10.1145/2771783.2771806)
* [65] Yit Phang Khoo, Bor-Yuh Evan Chang, and Jeffrey S. Foster. 2010. Mixing Type Checking and Symbolic Execution. In _Proc. 31st ACM SIGPLAN Conf. on Prog. Lang. Design and Impl. (PLDI'10)_. 436-447. [https://doi.org/10.1145/1806596.1806645](https://doi.org/10.1145/1806596.1806645)
* [66] Sarfraz Khurshid, Corina S. Pasareanu, and Willem Visser. 2003. Generalized Symbolic Execution for Model Checking and Testing. In _Proc. 9th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'03)_. Springer-Verlag, 553-568. [https://doi.org/10.1007/3-540-36577-x_40](https://doi.org/10.1007/3-540-36577-x_40)
* [67] James C. King. 1975. A New Approach to Program Testing. In _Proc. Int. Conf. on Reliable Software_. ACM, 228-233. [https://doi.org/10.1145/800027.808444](https://doi.org/10.1145/800027.808444)
* [68] James C. King. 1976. Symbolic Execution and Program Testing. _Commun. ACM_ 19, 7 (1976), 385-394. [https://doi.org/10.1145/360248.360252](https://doi.org/10.1145/360248.360252)
* [69] Daniel Kroening, Natash Sharygina, Stefano Tonetta, Aliaksei Tsitovich, and Christoph M. Wintersteiger. 2008. Loop Summarization Using Abstract Transformers. In _Proc. 6th Int. Symp. on Automated Technology for Verification and Analysis (ATVA'08)_. 111-125. [https://doi.org/10.1007/978-3-540-88387-6_10](https://doi.org/10.1007/978-3-540-88387-6_10)
* [70] Volodymyr Kuznetsov, Johannes Kinder, Stefan Bucur, and George Candea. 2012. Efficient State Merging in Symbolic Execution. In _Proc. 33rd ACM SIGPLAN Conf. on Prog. Lang. Design and Impl. (PLDI'12)_. ACM, 193-204. [https://doi.org/10.1145/22540482.2254088](https://doi.org/10.1145/22540482.2254088)
* [71] You Li, Zhendong Su, Linzhang Wang, and Xuandong Li. 2013. Steering Symbolic Execution to Less Traveled Paths. In _Proc. ACM SIGPLAN Conference on Object Oriented Programming Systems Languages & Applications (OOPSLA'13)_. 19-32. [https://doi.org/10.1145/2509136.2509553](https://doi.org/10.1145/2509136.2509553)
* [72] Kin-Keung Ma, Khoo Yit Phang, Jeffrey S. Foster, and Michael Hicks. 2011. Directed Symbolic Execution. In _Proc. 18th Int. Conf. on Static Analysis (SAS'11)_. 95-111.
* [73] Rupak Majumdar and Koushik Sen. 2007. Hybrid Concolic Testing. In _Proc. 29th Int. Conf. on Software Engineering (ICSE'07)_. IEEE Computer Society, 416-426. [https://doi.org/10.1109/ICSE.2007.41](https://doi.org/10.1109/ICSE.2007.41)
* [74] Rupak Majumdar and Ru-Gang Xu. 2009. Reducing Test Inputs Using Information Partitions. In _Proc. 21st Int. Conf. on Computer Aided Verification (CAV'09)_. Springer-Verlag, Berlin, Heidelberg, 555-569. [https://doi.org/10.1007/978-3-642-02658-4_41](https://doi.org/10.1007/978-3-642-02658-4_41)* [75] Kenneth L. McMillan. 2010. Lazy Annotation for Program Testing and Verification. In _Proc. 22nd Int. Conf. on Computer Aided Verification (CAV'10)_. 104-118. [https://doi.org/10.1007/978-3-642-14295-6_10](https://doi.org/10.1007/978-3-642-14295-6_10)
* [76] Phil McMinn. 2004. Search-based Software Test Data Generation: A Survey. _Software Testing, Verification & Reliability_ 14, 2 (2004), 105-156. [https://doi.org/10.1002/ytvr.142](https://doi.org/10.1002/ytvr.142)
* [77] Corina S. Pasareanu and Neha Rungta. 2010. Symbolic PathFinder: Symbolic Execution of Java Bytecode. In _Proc. IEEE/ACM Int. Conf. on Automated Software Engineering (ASE'10)_. ACM, 179-180. [https://doi.org/10.1145/1858996.1859035](https://doi.org/10.1145/1858996.1859035)
* [78] Corina S. Pasareanu, Neha Rungta, and Willem Visser. 2011. Symbolic Execution with Mixed Concrete-symbolic Solving. In _Proc. 2011 Int. Symp. on Software Testing and Analysis (ISSTA'11)_. ACM, 34-44. [https://doi.org/10.1145/2001420.2001425](https://doi.org/10.1145/2001420.2001425)
* [79] Corina S. Pasareanu and Willem Visser. 2009. A Survey of New Trends in Symbolic Execution for Software Testing and Analysis. _Int. Journal on Software Tools for Technology Transfer_ 11, 4 (2009), 339-353. [https://doi.org/10.1007/s10009-009-0118-1](https://doi.org/10.1007/s10009-009-0118-1)
* [80] David M. Perry, Andrea Mattavelli, Xiangyu Zhang, and Cristian Cadar. 2017. Accelerating Array Constraints in Symbolic Execution. In _Proc. 26th ACM SIGSOFT Int. Symp. on Software Testing and Analysis (ISSTA'17)_. ACM, 68-78. [https://doi.org/10.1145/3092703.3092728](https://doi.org/10.1145/3092703.3092728)
* [81] Ruizca Piskac, Thomas Wies, and Damien Zufferey. 2013. Automating Separation Logic Using SMT. In _Proc. 25th Int. Conf. on Computer Aided Verification (CAV'13)_. 773-789. [https://doi.org/10.1007/978-3-642-39799-8_54](https://doi.org/10.1007/978-3-642-39799-8_54)
* [82] Amir Pnueli and Roni Rosner. 1989. On the Synthesis of a Reactive Module. In _Proc. 16th ACM SIGPLAN-SIGACT Symp. on Principles of Progr. Lang. (POPL'89)_. ACM, 179-190. [https://doi.org/10.1145/75277.75293](https://doi.org/10.1145/75277.75293)
* [83] Charles Prud'homme, Jean-Guillaume Fages, and Xavier Lorca. 2015. _Chooc Documentation_. TASC, INRIA Rennes, LINA CNRS UMR 6241, OCSILING A.S. A.S. University., WW-choo-solverso.
* [84] Dawei Qi, Hoang D. T. Nguyen, and Abhik Roychoudhury. 2013. Path Exploration Based on Symbolic Output. _ACM Trans. on Software Engineering and Methodology (TOSEM) 22_, 4, Article 32 (2013).
* [85] David A. Ramos and Dawson R. Engler. 2015. Under-constrained Symbolic Execution: Correctness Checking for Real Code. In _Proc. 24th USENIX Conf. on Security Symp. (SEC'15)_. USENIX Association, 49-64.
* [86] John C. Reynolds. 2002. Separation Logic: A Logic for Shared Mutable Data Structures. In _Proc. 17th Annual IEEE Symp. on Logic in Computer Science (LICS'02)_. IEEE Computer Society, 55-74. [https://doi.org/10.1109/LICS.2002.1029817](https://doi.org/10.1109/LICS.2002.1029817)
* [87] Nicolas Rosner, Jaco Geldenhuys, Nazareno M. Aguirre, Willem Visser, and Marcelo F. Frias. 2015. BLISS: Improved Symbolic Execution by Bounded Lazy Initialization with SAT Support. _IEEE Trans. on Software Engineering (TSE)_ 41, 7 (2015), 639-660. [https://doi.org/10.1109/TSE.2015.2389225](https://doi.org/10.1109/TSE.2015.2389225)
* [88] Prateek Saxena, Pongsin Poosankam, Stephen McCamant, and Dawn Song. 2009. Loop-extended Symbolic Execution on Binary Programs. In _Proc. 18th Int. Symp. on Software Testing and Analysis_. 225-236. [https://doi.org/10.1145/157227.1572299](https://doi.org/10.1145/157227.1572299)
* [89] Edward J. Schwartz, Thanassis Avgerinos, and David Brumley. 2010. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask). In _Proc. 2010 IEEE Symp. on Security and Privacy (SP'10)_. IEEE Computer Society, 317-331. [https://doi.org/10.1109/SP.2010.26](https://doi.org/10.1109/SP.2010.26)
* [90] Daniel Schwartz-Narbonne, Martin Schaf, Dejan Jovanovic, Philipp Rummer, and Thomas Wies. 2015. Conflict-Directed Graph Coverage. In _NASA Formal Methods: 7th Int. Symp. 327-342. [https://doi.org/10.1007/978-3-319-17524-9_23](https://doi.org/10.1007/978-3-319-17524-9_23)
* [91] Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: A Concolic Unit Testing Engine for C. In _Proc. 10th European Software Engineering Conf. Held Jointly with 13th ACM SIGSOFT Int. Symp. on Foundations of Software Engineering (ESEC/FSE'13)_. ACM, 263-272. [https://doi.org/10.1145/1081706.1081750](https://doi.org/10.1145/1081706.1081750)
* [92] Ondrej Sery, Grigory Fedyukovich, and Natasha Sharygina. 2012. Incremental Upgrade Checking by Means of Interpolation-based Function Summaries. In _2012 Formal Methods in Computer-Aided Design (FMCAD'12)_. 114-121.
* [93] Ondrej Sery, Grigory Fedyukovich, and Natasha Sharygina. 2012. Interpolation-Based Function Summaries in Bounded Model Checking. In _Proc. 7th Int. Haifa Verification Conf. on Hardware and Software: Verification and Testing (HVC'11)_. 160-175. [https://doi.org/10.1007/978-3-642-34188-5_15](https://doi.org/10.1007/978-3-642-34188-5_15)
* 바이너리 펌웨어에서 인증 바이패스 취약성 자동 탐지. 22번째 연례 네트워크 및 분산 시스템 보안 심프. (NDSS'15)_. [https://doi.org/10.14722/ndss.2015.23294] (https://doi.org/10.14722/ndss.2015.23294)
* [95] Yan Shoshitaishvili, Ruqou Wang, Christopher Salls, Nick Stephens, Mario Polino, Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel, and Giovanni Vigna. 2016. SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis. In _IEEE Symp. on Security and Privacy (SP'16)_. 138-157. [https://doi.org/10.1109/SP.2016.17](https://doi.org/10.1109/SP.2016.17)
* [96] Jiri Slaby, Jan Strejcek, and Marek Trtik. 2013. Compact Symbolic Execution. In _11th Int. Symp. on Automated Technology for Verification and Analysis (ATVA'13)_. 193-207. [https://doi.org/10.1007/978-3-319-02444-8_15](https://doi.org/10.1007/978-3-319-02444-8_15)* [97] Armando Solar Lezama. 2008. _Program Synthesis By Sketching_. Ph.D. Dissertation. EECS Department, University of California, Berkeley. [http://www2.eecs.berkeley.edu/Pubs/TechRpts/2008/EECS-2008-177.html](http://www2.eecs.berkeley.edu/Pubs/TechRpts/2008/EECS-2008-177.html)
* [98] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena. 2008. BitBlaze: A New Approach to Computer Security via Binary Analysis. In _Proc. th Int. Conf. on Information Systems Security ((ICISS'08)_. 1-25. [https://doi.org/10.1007/978-3-540-89862-7_1](https://doi.org/10.1007/978-3-540-89862-7_1)
* [99] Litong Song and Krishna Kavi. 2004. What Can We Gain by Unfolding Loops? _SIGPLAN Not._ 39, 2 (2004), 26-33. [https://doi.org/10.1145/967278.967284](https://doi.org/10.1145/967278.967284)
* [100] Matheus Souza, Mateus Borges, Marcelo d'Amorim, and Corina S. Pasareanu. 2011. CORAL: Solving Complex Constraints for Symbolic Pathfinder. In _Proc. 3rd Int. NASA Formal Methods Symp._ 359-374.
* [101] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna. 2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In _23nd Annual Network and Distr. System Sec. Symp. (NDSS'16)_.
* [102] Aditya Thakur, Junghee Lim, Akash Lal, Amanda Burton, Evan Driscoll, Matt Elder, Tycho Andersen, and Thomas Reps. 2010. Directed Proof Generation for Machine Code. In _Proc. 22nd Int. Conf. on Computer Aided Verification (CAV'10)_. Springer-Verlag, 288-305. [https://doi.org/10.1007/978-3-642-14295-6_27](https://doi.org/10.1007/978-3-642-14295-6_27)
* [103] Marek Trtik and Jan Strejek. 2014. _Symbolic Memory with Pointers_. Springer Int. Publishing, 380-395. [https://doi.org/10.1007/978-3-319-11936-6_27](https://doi.org/10.1007/978-3-319-11936-6_27)
* [104] Alakaset Tsitovich, Natasha Sharygina, Christoph M. Wintersteiger, and Daniel Kroening. 2011. Loop Summarization and Termination Analysis. In _Proc. Theory and Practice of Software, Proc. 17th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'11/ETAPS'11)_. 81-95.
* [105] Heila van der Merwe, Oksana Tkachuk, Brink van der Merwe, and Willem Visser. 2015. Generation of Library Models for Verification of Android Applications. _SIGSOFT Software Engineering Notes_ 40, 1 (2015), 1-5.
* [106] Willem Visser, Jaco Geldenhuis, and Matthew B. Dwyer. 2012. Green: Reducing, Reusing and Recycling Constraints in Program Analysis. In _Proc. ACM SIGSOFT 20th Int. Symp. on the Foundations of Software Engineering (FSE'12)_. ACM, Article 58. [https://doi.org/10.1145/2393596.2393665](https://doi.org/10.1145/2393596.2393665)
* [107] Willem Visser, Corina S. Pasareanu, and Sarfraz Khurshid. 2004. Test Input Generation with Java PathFinder. In _Proc. 2004 ACM SIGSOFT Int. Symp. on Software Testing and Analysis_. ACM, 97-107. [https://doi.org/10.1145/1007512.1007526](https://doi.org/10.1145/1007512.1007526)
* [108] Jonas Wagner, Volodymy Kuznetsov, and George Candea. 2013. Overify: Optimizing Programs for Fast Verification. In _Proc. 14th USENIX Conf. on Hot Topics in Operating Systems_. USENIX Association.
* [109] Haijun Wang, Ting Liu, Xiaohong Guan, Chao Shen, Qinghua Zheng, and Zijiang Yang. 2017. Dependence Guided Symbolic Execution. _IEEE Trans. on Software Engineering (TSE)_ 43, 3 (2017), 252-271.
* [110] Mark Weiser. 1984. Program Slicing. _IEEE Trans. on Software Engineering_ SE-10, 4 (1984), 352-357. [https://doi.org/10.1109/TSE.1984.5010248](https://doi.org/10.1109/TSE.1984.5010248)
* [111] Xusheng Xiao, Tao Xie, Nikolai Tillmann, and Jonathan de Halleux. 2011. Precise Identification of Problems for Structural Test Generation. In _Proc. 33rd Int. Conf. on Software Engineering (ICSE'11)_. 611-620. [https://doi.org/10.1145/1985739.1985876](https://doi.org/10.1145/1985739.1985876)
* [112] Tao Xie, Nikolai Tillmann, Jonathan de Halleux, and Wolfram Schulte. 2009. Fitness-guided path exploration in dynamic symbolic execution. In _Proc. 2009 IEEE/IFIP Int. Conf. on Dependable Systems and Networks (DSN'09)_. 359-368. [https://doi.org/10.1109/DSN.2009.5270315](https://doi.org/10.1109/DSN.2009.5270315)
* [113] Xiaofei Xie, Bihuan Chen, Yang Liu, Wei Le, and Xiaohong Li. 2016. Proteus: Computing Disjunctive Loop Summary via Path Dependency Analysis. In _Proc. 2016 24th ACM SIGSOFT Int. Symp. on Foundations of Software Engineering (FSE'16)_. 61-72. [https://doi.org/10.1145/2950290.2950340](https://doi.org/10.1145/2950290.2950340)
* [114] Yichen Xie and Alex Aiken. 2005. Scalable Error Detection Using Boolean Satisfiability. In _Proc. 32nd ACM SIGPLAN-SIGACT Symp. on Principles of Progr. Lang. (POPL'05)_. ACM, 351-363. [https://doi.org/10.1145/1040305.1040334](https://doi.org/10.1145/1040305.1040334)
* [115] Guowei Yang, Corina S. Pasareanu, and Sarfraz Khurshid. 2012. Memoized Symbolic Execution. In _Proc. 2012 Int. Symp. on Software Testing and Analysis (ISSTA'12)_. ACM, 144-154. [https://doi.org/10.1145/2338965.2336771](https://doi.org/10.1145/2338965.2336771)
* [116] Guowei Yang, Suzette Person, Neba Rungta, and Sarfraz Khurshid. 2014. Directed Incremental Symbolic Execution. _ACM Trans. on Software Engineering and Methodology (TOSEA)_ 24, 1, Article 3 (2014). [https://doi.org/10.1145/2629536](https://doi.org/10.1145/2629536)
* [117] Qiuping Yi, Zijiang Yang, Shengjian Guo, Chao Wang, Jian Liu, and Chen Zhao. 2015. Postconditioned Symbolic Execution. In _2015 IEEE 8th Int. Conf. on Software Testing, Verification and Validation (ICST)_. [https://doi.org/10.1109/ICST.2015.7102601](https://doi.org/10.1109/ICST.2015.7102601)
* [118] Yufeng Zhang, Zhenbang Chen, Ji Wang, Wei Dong, and Zhiming Liu. 2015. Regular Property Guided Dynamic Symbolic Execution. In _Proc. 37th Int. Conf. on Software Engineering (ICSE'15)_. 643-653.
* [119] Yunhui Zheng, Xiangyu Zhang, and Vijay Ganesh. 2013. Z3-str: A Z3-based String Solver for Web Application Analysis. In _Proc. 2013 9th Joint Meeting on Foundations of Software Engineering_. ACM, 114-124.
